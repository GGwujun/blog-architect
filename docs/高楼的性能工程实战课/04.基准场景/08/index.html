<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      17 | 查询购物车：为什么铺底参数一定要符合真实业务特性？ - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/高楼的性能工程实战课/04.基准场景/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></span><span>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></li><li>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li><li><a href="/blog-architect/高楼的性能工程实战课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/01.开篇词/01"><span>开篇词 | 打破四大认知局限，进阶高级性能工程师</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念">02.性能工程的核心理念</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/01"><span>01 | 性能工程：为什么很多性能测试人员无法对性能结果负责？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/02"><span>02 | 关键概念：性能指标和场景的确定</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/03"><span>03 | 核心分析逻辑：所有的性能分析，靠这七步都能搞定</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04"><span>04 | 如何构建性能分析决策树和查找瓶颈证据链？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点">03.性能工程的实践关键点</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/01"><span>05 | 性能方案：你的方案是否还停留在形式上？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/02"><span>06 | 如何抽取出符合真实业务场景的业务模型？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/03"><span>07 | 性能场景的数据到底应该做成什么样子？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/04"><span>08 | 并发、在线和TPS到底是什么关系？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/05"><span>09 | 如何设计全局和定向监控策略？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课/04.基准场景">04.基准场景</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/01"><span>10 | 设计基准场景需要注意哪些关键点？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/02"><span>11 | 打开首页之一：一个案例，带你搞懂基础硬件设施的性能问题</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/03"><span>12 | 打开首页之二：如何平衡利用硬件资源？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/04"><span>13 | 用户登录：怎么判断线程中的Block原因？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/05"><span>14 | 用户信息查询：如何解决网络软中断瓶颈问题？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/06"><span>15 | 查询商品：资源不足有哪些性能表现？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/07"><span>16 | 商品加入购物车：SQL优化和压力工具中的参数分析</span></a></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08"><span>17 | 查询购物车：为什么铺底参数一定要符合真实业务特性？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/09"><span>18 | 购物车信息确定订单：为什么动态参数化逻辑非常重要？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/10"><span>19 | 生成订单信息之一：应用JDBC池优化和内存溢出分析</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/11"><span>20 | 生成订单信息之二：业务逻辑复杂，怎么做性能优化？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/12"><span>21 | 支付前查询订单列表：如何分析优化一个固定的技术组件？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/13"><span>22 | 支付订单信息：如何高效解决for循环产生的内存溢出？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景">05.容量稳定性异常场景</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/01"><span>23 | 决定容量场景成败的关键因素有哪些？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/02"><span>24 | 容量场景之一：索引优化和Kubernetes资源分配不均衡怎么办？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/03"><span>25 | 容量场景之二：缓存对性能会有什么样的影响？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/04"><span>26 | 稳定性场景之一：怎样搞定业务积累量产生的瓶颈问题？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/05"><span>27 | 稳定性场景之二：怎样搞定磁盘不足产生的瓶颈问题？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/06"><span>28 | 如何确定异常场景的范围和设计逻辑？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/07"><span>29 | 异常场景：如何模拟不同组件层级的异常？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/06.特别放送">06.特别放送</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/06.特别放送/01"><span>我们这个课程的系统是怎么搭建起来的？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/07.性能结论">07.性能结论</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/07.性能结论/01"><span>30 | 如何确定生产系统配置？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/07.性能结论/02"><span>31 | 怎么写出有价值的性能报告？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/08.结课测试">08.结课测试</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/08.结课测试/01"><span>一套习题，测出你的掌握程度</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/09.结束语">09.结束语</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/09.结束语/01"><span>结束语 | 做真正的性能项目</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/summary">高楼的性能工程实战课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="压力数据" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#压力数据"><span>压力数据</span></a></li><li title="架构图" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#架构图"><span>架构图</span></a></li><li title="第一阶段分析" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#第一阶段分析"><span>第一阶段分析</span></a></li><li title="拆分响应时间" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#拆分响应时间"><span>拆分响应时间</span></a></li><li title="定向监控分析" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#定向监控分析"><span>定向监控分析</span></a></li><li title="优化效果" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#优化效果"><span>优化效果</span></a></li><li title="第二阶段分析" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#第二阶段分析"><span>第二阶段分析</span></a></li><li title="全局监控分析" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#全局监控分析"><span>全局监控分析</span></a></li><li title="定向监控分析" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#定向监控分析-1"><span>定向监控分析</span></a></li><li title="总结" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="17--查询购物车为什么铺底参数一定要符合真实业务特性"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#17--查询购物车为什么铺底参数一定要符合真实业务特性"><span class="icon icon-link"></span></a>17 | 查询购物车：为什么铺底参数一定要符合真实业务特性？</h1><p>你好，我是高楼。</p><p>今天我们来看看查询购物车接口。</p><p>到现在为止，这是我们分析的第六个接口了。不过，我希望你能明白，我们分析每个接口，并不是为了搞清楚这个接口本身的逻辑，而是通过不同接口的基准测试，来分析不同的性能问题，争取给你带来更多的分析案例。</p><p>现在很多人在性能场景执行过程中，仍然会问出“当铺底数据不符合生产环境时，该怎么办”这样的疑问，其实答案也挺简单，那就是模拟不出生产环境中的问题。</p><p>所以，在这节课中，你将看到当铺底数据不合理时，会对TPS产生什么样具体的影响。由此，你会进一步理解为什么我一直在跟你强调<strong>铺底数据要符合生产环境逻辑</strong>。</p><p>此外，我们还会分析另一个问题，这个问题可能会让你看着比较郁闷，你会发现我们分析了很久，逻辑看似非常合理，但是结果并不如人意。面对这样的情况，那我们该怎么处理呢？这里留个悬念，我们直接开始今天的分析。</p><h2 id="压力数据"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#压力数据"><span class="icon icon-link"></span></a>压力数据</h2><p>对于查询购物车这个接口，还是一样，我们先来看第一次运行的性能场景结果。这是一个一开始就足以让人心碎的性能数据：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage6be36be835b024ebcdyyb8b37yy716bee1e3.1623c553.png" alt=""/></p><p>你看，线程数在增加的过程中，TPS只达到40，而响应时间从一开始就不断地增加。</p><p>这可怎么办呢？根据我们RESAR性能分析逻辑，第一步仍然是看架构图，接着是拆分响应时间。因为响应时间在不断增加，所以我们想要拆分响应时间非常容易。</p><h2 id="架构图"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#架构图"><span class="icon icon-link"></span></a>架构图</h2><p>在拆分响应时间之前，我们看一下架构图。在这一步，你只需要把架构图记个大概就行了。因为后面还要反复回来看多次。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage4d3c4d60c5c09byy55e72b058c5871e3bf3c.67c73f8e.png" alt=""/></p><h2 id="第一阶段分析"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#第一阶段分析"><span class="icon icon-link"></span></a>第一阶段分析</h2><h3 id="拆分响应时间"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#拆分响应时间"><span class="icon icon-link"></span></a>拆分响应时间</h3><p>我们反反复复在讲，<strong>做性能分析的时候，首先就是拆分时间</strong>。</p><p>别人在问我问题的时候，经常会这样描述：TPS不高，响应时间长，瓶颈在哪呢？一看到这种问题，我通常会反问：响应时间长在哪呢？然后，经典的对话结束语就出现了——我不知道呀。我也很想帮助对方解决问题，但是，对于这样的描述，我根本无从下手。</p><p>一个做性能的人，怎么能只描述响应时间长呢？你至少要告诉别人慢在哪里。这就是为什么我一直在强调要画架构图。因为有了图，才有拆分时间的手段，这样一来，我们自然就不会盲目，除非你啥都没有。</p><p>在拆分时间的时候，你还要注意一点，<strong>要找准时间段</strong>。根据我的经验，一般是看响应时间的趋势，如果一直都长的话，倒是简单，看哪一段响应时间都行。要是有的时候长，有的时候短，那你就要注意了，在拆分响应时间的时候，要注意把监控工具中的时间段选择好。</p><p>在这里，我们选择SkyWalking时间段：<code>2021-01-02 13:53:00 \- 2021-01-02 13:54:00</code>。具体拆分时间如下：</p><ul><li>User - Gateway：</li></ul><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage4d824d7a06yy402957608011dd69b8e8fd82.45699e5a.png" alt=""/></p><ul><li>Gateway：</li></ul><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage0d3b0d466c07da6d2db5fff60abc32e0ec3b.fada6ff5.png" alt=""/></p><ul><li>Gateway - Cart：</li></ul><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage5cff5c0fbf24959d98c5787f64def5026fff.ae97ed06.png" alt=""/></p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagece49ced9b3920d9d00ab06b3d443bbae8649.55f76d74.png" alt=""/></p><ul><li>Cart：</li></ul><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagebab5bayy3fc2a1e2958789e5f3410f6498b5.9a8f6df8.png" alt=""/></p><ul><li>Cart - MySQL：</li></ul><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimaged2b2d22c0a2ee7180ecde6f97505e467e9b2.6c7d3c9e.png" alt=""/></p><p>通过上面抓取的数据，你明显可以看到，是购物车服务Cart那一段的响应时间长。</p><p>我们要注意，有些数据抓取工具由于工具本身的问题，会存在不小的数据偏差，比如说对于上面的SkyWalking时间段，我们看到Gateway - Cart之间的服务端平均响应时间是829.25。但是，在Cart上却是984.50。同样的一段时间，这里就出现了一些偏差。</p><p>在每一个监控工具上，都或多或少存在性能数据偏差，就比如docker stats，我简直是不想看。所以，我们有时候要结合多个工具来对比数据。</p><h3 id="定向监控分析"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#定向监控分析"><span class="icon icon-link"></span></a>定向监控分析</h3><p>拆分完响应时间后，我们不再从全局分析开始，而是直接跳到了定向监控。因为对于查询购物车这个接口，我们已经知道Cart服务是慢的，所以，我们就直接进去查看对应的慢的方法在哪里。</p><p>这个接口的调用方法如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * 根据会员id查询购物车数据</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @param memberId 会员id</span></div><div class="token-line"><span class="token plain">     * @return</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @Override</span></div><div class="token-line"><span class="token plain">    public List&lt;OmsCartItem&gt; list(Long memberId) {</span></div><div class="token-line"><span class="token plain">        if (memberId == null) {</span></div><div class="token-line"><span class="token plain">            return null;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        OmsCartItemExample example = new OmsCartItemExample();</span></div><div class="token-line"><span class="token plain">        example.createCriteria().andDeleteStatusEqualTo(0).andMemberIdEqualTo(memberId);</span></div><div class="token-line"><span class="token plain">        return cartItemMapper.selectByExample(example);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过上面的代码，我们知道了方法名，那我们直接用Arthas来Trace这个接口就好了，命令如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">trace com.dunshan.mall.cart.service.imp.CartItemServiceImpl list -v -n 5 --skipJDKMethod false &#x27;1==1&#x27;</span></div></pre></div><p>于是，我们得到了如下的信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[arthas@1]$ trace com.dunshan.mall.cart.service.imp.CartItemServiceImpl list -v -n 5 --skipJDKMethod false &#x27;1==1&#x27;</span></div><div class="token-line"><span class="token plain">    Condition express: 1==1 , result: true</span></div><div class="token-line"><span class="token plain">    `---ts=2021-01-02 14:59:53;thread_name=http-nio-8086-exec-556;id=10808;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@18c26588</span></div><div class="token-line"><span class="token plain">        `---[999.018045ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl$$EnhancerBySpringCGLIB$$e110d1ef:list()</span></div><div class="token-line"><span class="token plain">            `---[998.970849ms] org.springframework.cglib.proxy.MethodInterceptor:intercept() #57</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Condition express: 1==1 , result: true</span></div><div class="token-line"><span class="token plain">    `---ts=2021-01-02 14:59:54;thread_name=http-nio-8086-exec-513;id=107d3;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@18c26588</span></div><div class="token-line"><span class="token plain">        `---[1095.593933ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl$$EnhancerBySpringCGLIB$$e110d1ef:list()</span></div><div class="token-line"><span class="token plain">            `---[1095.502983ms] org.springframework.cglib.proxy.MethodInterceptor:intercept() #57</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Condition express: 1==1 , result: true</span></div><div class="token-line"><span class="token plain">    `---ts=2021-01-02 14:59:53;thread_name=http-nio-8086-exec-505;id=1078b;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@18c26588</span></div><div class="token-line"><span class="token plain">        `---[2059.097767ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl$$EnhancerBySpringCGLIB$$e110d1ef:list()</span></div><div class="token-line"><span class="token plain">            `---[2059.013275ms] org.springframework.cglib.proxy.MethodInterceptor:intercept() #57</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Condition express: 1==1 , result: true</span></div><div class="token-line"><span class="token plain">    `---ts=2021-01-02 14:59:54;thread_name=http-nio-8086-exec-541;id=107f6;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@18c26588</span></div><div class="token-line"><span class="token plain">        `---[1499.559298ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl$$EnhancerBySpringCGLIB$$e110d1ef:list()</span></div><div class="token-line"><span class="token plain">            `---[1499.498896ms] org.springframework.cglib.proxy.MethodInterceptor:intercept() #</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    通过上面的数据可以看到list()的响应时间确实是长了，但是这个接口并不复杂，就是一个select语句而已。对应的select语句的Mapper内容如下：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;select id=&quot;selectByExample&quot; parameterType=&quot;com.dunshan.mall.model.OmsCartItemExample&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span></div><div class="token-line"><span class="token plain">        select</span></div><div class="token-line"><span class="token plain">        &lt;if test=&quot;distinct&quot;&gt;</span></div><div class="token-line"><span class="token plain">          distinct</span></div><div class="token-line"><span class="token plain">        &lt;/if&gt;</span></div><div class="token-line"><span class="token plain">        &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        from oms_cart_item</span></div><div class="token-line"><span class="token plain">        &lt;if test=&quot;_parameter != null&quot;&gt;</span></div><div class="token-line"><span class="token plain">          &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/if&gt;</span></div><div class="token-line"><span class="token plain">        &lt;if test=&quot;orderByClause != null&quot;&gt;</span></div><div class="token-line"><span class="token plain">          order by ${orderByClause}</span></div><div class="token-line"><span class="token plain">        &lt;/if&gt;</span></div><div class="token-line"><span class="token plain">      &lt;/select&gt;</span></div></pre></div><p>这个Mapper对应到数据库中，具体的SQL就是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SELECT id, product_id, product_sku_id, member_id, quantity, price, product_pic, product_name, product_sub_title, product_sku_code, member_nickname, create_date, modify_date, delete_status, product_category_id, product_brand, product_sn, product_attr FROM oms_cart_item WHERE (  delete_status = 0  AND member_id = 597427  )</span></div></pre></div><p>既然是一个select语句消耗的时间长，那我们就到数据库里，根据相应的SQL来看对应表的数据直方图。命令如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">select member_id,count(*) from oms_cart_item_202101021530 GROUP BY 1 ORDER BY 2 DESC;</span></div></pre></div><p>结果如下，我们截取了直方图的部分数据：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage95bf954ca65681d0f21602f6c477c1e5e6bf.5ff7185d.png" alt=""/></p><p>从上述数据库中的数据来看，一个会员ID的下面已经加了不少数据。虽然select是通过会员ID查的，但是没做分页处理。这是最简单直接的SQL问题了，分析过程也非常简单。当我们一看到SQL时间长的时候，就要查看一下执行计划：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage7dc07d1726dd3ea450bef207b96261b883c0.28b70e9b.png" alt=""/></p><p>既然上面的type值是ALL，说明走的是全表扫描，那我们就要根据SQL中的where条件来确定一下要创建什么索引；如果where条件中的查询结果是多条结果，并且数据较多，那就需要做分页。分析到这里，其实也比较容易想到对应的解决方案，有两个动作要做：</p><ol><li>创建索引：创建索引是为了查询的时候可以精准查询。</li><li>做分页：是为了避免返回到前端的数据太多。</li></ol><h3 id="优化效果"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#优化效果"><span class="icon icon-link"></span></a>优化效果</h3><p>我们虽然讲的是“优化效果”，但，准确来说只是“验证效果”。因为上面的两个动作都是为了提高SQL的查询效果，确切来说就为了减少查询出来的数据。那我们现在就直接把数据给降下来，来验证我们的判断是不是正确。</p><p>为了验证我们的分析过程是正确的，这里我先直接把表给TRUNCATE掉，先看看响应时间能不能上来。如果能上来，那就是这里的问题了。</p><p>可如果不是呢？那我们只能回到角落默默流泪了。这么简单的问题都找不到，我不是一个合格的性能分析人员。</p><p>不管怎么说，来，我们看下结果：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagec0f1c0c511412da730a61d7ff0d166d1f1f1.4986de04.png" alt=""/></p><p>可以看到，TPS一下子上升了很多，在场景不间断的情况下，这个比对如此喜人。看来，我还能继续干这一行。</p><p>不过，我们的分析到这里并没有结束，屋漏偏逢连夜雨，我在接着做压力的过程中，又出现了状况，这让我们不得不进入第二个阶段的分析。</p><h2 id="第二阶段分析"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#第二阶段分析"><span class="icon icon-link"></span></a>第二阶段分析</h2><p>到底又出现了什么问题呢？具体情况如下：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage4802486a53a0d5d9af7f985e61f91fecd702.a0ee5e9d.png" alt=""/></p><p>What? 那是TPS曲线吗？那是掉下来了吗？掉的还这么多吗？同样是场景不间断啊。我的职业生涯难道要就此断送了吗？</p><p>这个问题有点复杂。但是从响应时间曲线上看，明显是响应时间增加了，TPS下来了。既然这样，仍然走我们拆分响应时间的思路就好了，这里不再赘述。</p><p>通过拆分时间，我们知道响应时间长的问题出在了Gateway上。下面我们就根据RESAR性能分析逻辑，老老实实开始分析。</p><h3 id="全局监控分析"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#全局监控分析"><span class="icon icon-link"></span></a>全局监控分析</h3><p>我们从系统级的资源上可以明显看到，所有的worker节点都无压力。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagee3d4e351d44ec9be9300597431ca6b28c1d4.6b634b5f.png" alt=""/></p><p>我们再从Pod角度来看一下：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagef3f0f355e78f2869e77b1625b4b57555c2f0.df7f0d77.png" alt=""/></p><p>你看，有些Pod消耗的CPU已经达到了100%。我把所有的Pod排个序，结果如下：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage91ed9123f41165957b2761ecb02e781133ed.df732fb2.png" alt=""/></p><p>虽然我们看到了像node_exporter、ES相关的Pod资源都用得不低，但是这些CPU使用率高的节点Pod的资源也都限制了。同时，你要注意，这个资源占用率高的Pod中并没有我们的应用节点，也就是说我们应用节点的CPU资源并没有用完。</p><p>我本来想去看一下在这段时间内，应用所在的worker上的内存消耗具体是怎样的。但是，在这段时间内却没了数据：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage4d704d8c352b4762747fe30480e43180e170.9742cbb1.png" alt=""/></p><p>你看，中间的数据已经断掉了，node_exporter已经不传数了。没有办法，我们只有放弃看 worker上的内存消耗了。</p><p>既然如此，那我们先查一下Gateway在哪个worker上，同时也来看一下这个worker上有多少Pod。走这一步是因为在整个Kubernetes中，所有的namespace都用worker主机的资源。所以，从资源使用的角度来看，我们要考虑到所有命名空间中的Pod。</p><p>所有namespace在应用节点上的所有Pod如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">- 先查询gateway所在的worker节点名</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      [root@k8s-master-2 ~]# kubectl get pods --all-namespaces -o wide | grep gateway</span></div><div class="token-line"><span class="token plain">        default                gateway-mall-gateway-6567c8b49c-pc7rf        1/1     Running   0          15h     10.100.140.2     k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    - 再查询对应worker上的所有POD</span></div><div class="token-line"><span class="token plain">    [root@k8s-master-2 ~]# kubectl get pods --all-namespaces -o wide | grep k8s-worker-2</span></div><div class="token-line"><span class="token plain">    default                elasticsearch-client-1                       1/1     Running   4          20d     10.100.140.28    k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    default                elasticsearch-data-2                         1/1     Running   0          4d2h    10.100.140.35    k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    default                elasticsearch-master-2                       1/1     Running   4          20d     10.100.140.30    k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    default                gateway-mall-gateway-6567c8b49c-pc7rf        1/1     Running   0          15h     10.100.140.2     k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    kube-system            calico-node-rlhcc                            1/1     Running   0          2d5h    172.16.106.149   k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    kube-system            coredns-59c898cd69-sfd9w                     1/1     Running   4          36d     10.100.140.31    k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    kube-system            kube-proxy-l8xf9                             1/1     Running   6          36d     172.16.106.149   k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    monitoring             node-exporter-mjsmp                          2/2     Running   0          4d17h   172.16.106.149   k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    nginx-ingress          nginx-ingress-nbhqc                          1/1     Running   0          5d19h   10.100.140.34    k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span></div><div class="token-line"><span class="token plain">    [root@k8s-master-2 ~]#</span></div></pre></div><p>从上面的结果可以看到，我们的worker节点上有9个Pod。</p><p>不过我们一开始看全局资源信息的时候，并没有发现整个worker节点的资源使用率很高。这是因为我们已经在Pod里限制了资源。所以我们列一下每个Pod的资源限制：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage421142e9797ac167e0d058f585c12b762b11.bca44f40.jpg" alt=""/></p><p>对于那些其他资源占用不高的Pod，我们就不看了。</p><p>既然资源有限制，那我们还要把目光转回到Gateway上面来。</p><h3 id="定向监控分析-1"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#定向监控分析-1"><span class="icon icon-link"></span></a>定向监控分析</h3><p>通过查看链路时间，我们也能知道是Gateway上消耗的时间较长：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage01a70153e9a21e1c4428d6f602bcb11a1da7.2799402b.png" alt=""/></p><p>但是，这个sendRequest是干嘛的？不知道。</p><p>那我们就做一个试验，看看跳过Gateway之后的TPS是多少。：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage16311694f3dd8195b96cf0d0fe57254bb331.fb5ace15.png" alt=""/></p><p>可见，走Gateway，TPS只能有400多；不走Gateway，TPS能达到800多。所以，问题确实出在了Gateway上。</p><p>看到这里，有一个环节我们是缺失的，那就是查看Kubernetes容器里的Java进程的健康状态。因为我们在前面查了worker，也查了worker上的Pod，所以现在就到了第三层，也就是Pod中的Java应用。</p><p>对此，你也不用有负担，你想想对于一个Java应用来说，能有个啥？无非就是堆、栈一顿看。来，我们打印个Gateway的栈看一下。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage483f48930f2e0cd5464def2c0169b7bcdd3f.edbfdde5.png" alt=""/></p><p>从栈上，啥也没看出来，整个状态似乎都挺合理的。 注意，在这里我不是只看一个截图哦，我已经把整个栈都撸了一遍。由于CPU也不高，我们在分析栈的时候，主要看一下有没有锁等待。从上图可以看到，并没有锁，等待也都合理。</p><p>看完栈之后，接下来该看堆了。我们得想尽办法，把Kubernetes的Java进程堆拿出来看看：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage90819035c1762a408b1a56650a01b175aa81.8f5f3a24.png" alt=""/></p><p>看到没！如此规则的关联关系：TPS和Gateway的GC趋势是完全一致的。</p><p>不过，这样看还是不够具体，我们还需要更细的数据。所以，我们进去看一下GC状态：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@gateway-mall-gateway-6567c8b49c-pc7rf /]# jstat -gcutil 1 1000 1000</span></div><div class="token-line"><span class="token plain">      S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span></div><div class="token-line"><span class="token plain">      0.00  55.45  45.33  52.96  94.74  92.77  38427 1953.428    94  113.940 2067.368</span></div><div class="token-line"><span class="token plain">     57.16   0.00  26.86  53.24  94.74  92.77  38428 1954.006    94  113.940 2067.946</span></div><div class="token-line"><span class="token plain">      0.00  54.30  15.07  53.65  94.74  92.77  38429 1954.110    94  113.940 2068.050</span></div><div class="token-line"><span class="token plain">     39.28   0.00  18.39  53.84  94.74  92.77  38430 1954.495    94  113.940 2068.435</span></div><div class="token-line"><span class="token plain">     39.28   0.00  81.36  53.84  94.74  92.77  38430 1954.495    94  113.940 2068.435</span></div><div class="token-line"><span class="token plain">      0.00  26.13  68.79  53.84  94.74  92.77  38431 1954.597    94  113.940 2068.537</span></div><div class="token-line"><span class="token plain">     39.18   0.00  59.75  53.84  94.74  92.77  38432 1954.683    94  113.940 2068.624</span></div><div class="token-line"><span class="token plain">      0.00  24.70  76.28  53.84  94.74  92.77  38433 1954.794    94  113.940 2068.734</span></div></pre></div><p>你看，一次YGC大概需要100ms，一秒一次YGC，这样YGC就占了10%左右，这个时间有点多了。</p><p>既然YGC消耗CPU较高，那我们就考虑优化Java参数。先来看一下Java参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@gateway-mall-gateway-6567c8b49c-pc7rf /]# jinfo -flags 1</span></div><div class="token-line"><span class="token plain">    Attaching to process ID 1, please wait...</span></div><div class="token-line"><span class="token plain">    Debugger attached successfully.</span></div><div class="token-line"><span class="token plain">    Server compiler detected.</span></div><div class="token-line"><span class="token plain">    JVM version is 25.242-b08</span></div><div class="token-line"><span class="token plain">    Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=262144000 -XX:+ManagementServer -XX:MaxHeapSize=4164943872 -XX:MaxNewSize=1388314624 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=87359488 -XX:OldSize=174784512 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span></div><div class="token-line"><span class="token plain">    Command line:  -Dapp.id=svc-mall-gateway -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.service_name=svc-mall-gateway -Dskywalking.collector.backend_service=skywalking-oap:11800 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.rmi.port=1100 -Djava.rmi.server.hostname=localhost -Dspring.profiles.active=prod -Djava.security.egd=file:/dev/./urandom</span></div><div class="token-line"><span class="token plain">    [root@gateway-mall-gateway-6567c8b49c-pc7rf /]#</span></div></pre></div><p>从上面的参数中就可以看到，我在Kubernetes的Java进程中并没有配置GC回收相关的参数。所以，这里我们加上相关的参数。</p><p>在下面的参数中，我加了PrintGC相关的参数以及ParNew参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@gateway-mall-gateway-6c6f486786-mnd6j /]# jinfo -flags 1</span></div><div class="token-line"><span class="token plain">    Attaching to process ID 1, please wait...</span></div><div class="token-line"><span class="token plain">    Debugger attached successfully.</span></div><div class="token-line"><span class="token plain">    Server compiler detected.</span></div><div class="token-line"><span class="token plain">    JVM version is 25.261-b12</span></div><div class="token-line"><span class="token plain">    Non-default VM flags: -XX:CICompilerCount=2 -XX:CompressedClassSpaceSize=1065353216 -XX:+HeapDumpOnOutOfMemoryError -XX:InitialHeapSize=2147483648 -XX:+ManagementServer -XX:MaxHeapSize=2147483648 -XX:MaxMetaspaceSize=1073741824 -XX:MaxNewSize=1073741824 -XX:MetaspaceSize=1073741824 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=1073741824 -XX:OldSize=1073741824 -XX:ParallelGCThreads=6 -XX:+PrintGC -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintTenuringDistribution -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParNewGC </span></div><div class="token-line"><span class="token plain">    Command line:  -Dapp.id=svc-mall-gateway -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.service_name=svc-mall-gateway -Dskywalking.collector.backend_service=skywalking-oap:11800 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.rmi.port=1100 -Djava.rmi.server.hostname=localhost -Xms2g -Xmx2g -XX:MetaspaceSize=1g -XX:MaxMetaspaceSize=1g -Xmn1g -XX:+UseParNewGC -XX:ParallelGCThreads=6 -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCDetails -Xloggc:gc.log -Dspring.profiles.active=prod -Djava.security.egd=file:/dev/./urandom</span></div><div class="token-line"><span class="token plain">    [root@gateway-mall-gateway-6c6f486786-mnd6j /]#</span></div></pre></div><p>本来指望ParNew能有啥用，然而并没有什么用。</p><p>既然加参数不是能很快见效的，那我们就得看一下YGC的时候回收了什么，然后再来决定从哪里下手收拾Java进程内存的消耗问题。所以，我们打印一下jmap histo信息，来看一下对象消耗内存的变化，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@gateway-mall-gateway-6c6f486786-mnd6j /]# jmap -histo 1 | head -20</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">     num     #instances         #bytes  class name</span></div><div class="token-line"><span class="token plain">    ----------------------------------------------</span></div><div class="token-line"><span class="token plain">       1:       2010270      124874960  [C</span></div><div class="token-line"><span class="token plain">       2:        787127       91014984  [I</span></div><div class="token-line"><span class="token plain">       3:        601333       42467920  [Ljava.lang.Object;</span></div><div class="token-line"><span class="token plain">       4:       1534551       36829224  java.lang.String</span></div><div class="token-line"><span class="token plain">       5:        420603       31107504  [B</span></div><div class="token-line"><span class="token plain">       6:         21891       21972896  [Ljava.util.concurrent.ConcurrentHashMap$Node;</span></div><div class="token-line"><span class="token plain">       7:        186170       11914880  java.util.regex.Matcher</span></div><div class="token-line"><span class="token plain">       8:        228807       10982736  java.util.StringTokenizer</span></div><div class="token-line"><span class="token plain">       9:        291025        9312800  java.util.concurrent.ConcurrentHashMap$Node</span></div><div class="token-line"><span class="token plain">      10:        274253        8804936  [Ljava.lang.String;</span></div><div class="token-line"><span class="token plain">      11:        179524        8617152  org.springframework.web.util.pattern.PathPattern$MatchingContext</span></div><div class="token-line"><span class="token plain">      12:        210473        8418920  java.util.LinkedHashMap$Entry</span></div><div class="token-line"><span class="token plain">      13:        154562        6182480  io.netty.handler.codec.DefaultHeaders$HeaderEntry</span></div><div class="token-line"><span class="token plain">      14:        191349        6123168  java.util.LinkedList</span></div><div class="token-line"><span class="token plain">      15:        126218        6058464  java.util.TreeMap</span></div><div class="token-line"><span class="token plain">      16:         68528        6030464  java.lang.reflect.Method</span></div><div class="token-line"><span class="token plain">      17:         98411        5363408  [Ljava.util.HashMap$Node;</span></div><div class="token-line"><span class="token plain">    [root@gateway-mall-gateway-6c6f486786-mnd6j /]#</span></div></pre></div><p>在这里，我们需要把这个命令多执行几次，看看对象消耗内存的变化。前面我们看到YGC过于频繁，但是从内存上来看，对象的内存回收得挺好。</p><p>所以，对于这种YGC很高，但从对象内存的消耗又看不出什么有效信息的问题，只有一种可能，那就是对象创建得快，销毁也快。那么，我们只有一个地方可以准确查找对象内存的消耗了，那就是对象的delta。我们连上JvisualVM，看下内存对象delta变量：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage5731572cf090832be1da53f0fd04f8e27e31.138d7f9d.png" alt=""/></p><p>（注：这张图上的字之所以这么小，是因为我连的是远程Windows桌面，分辨率不高，实在没有办法。不过，你要是仔细看的话，还是能看到最上面那个HashMap。）</p><p>我比较喜欢用这种视图来看delta值。从这里可以看到，增加和销毁都很快。</p><p>在前面我们加了打印GC log的参数，所以我们把GC log拿出来分析一下，得到结果如下：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage860186783a376c32ca492f6b0e7efed5d101.6fd371a5.png" alt=""/></p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage691169a1628494465a42dc29361bd1bc2811.c5ffec72.png" alt=""/></p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage9341937e064499296cfa20442bf6d3aaec41.d1a3a322.png" alt=""/></p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagea9f2a948d415bd3b32d437edbd0816757ff2.d32f97eb.png" alt=""/></p><p>从上面的分析来看，主要是YGC在消耗响应时间。这与我们前面的分析吻合，但是我们仍旧没有找到具体的问题点。</p><p>在这个问题的分析过程中，我不断在做应用的修改、重启等动作。结果，没想到性能问题没解决，又遇到了两个其他问题，特地记录在这里。</p><p>之所以记录这样的问题，是想告诉你：<strong>在我们的分析过程中，什么样的问题都有可能存在。而我们虽说是做性能分析的人，但也不是只分析性能问题，而是见到问题就要去解决，要不然，你就走不下去</strong>。</p><h4 id="支线问题一"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#支线问题一"><span class="icon icon-link"></span></a>支线问题一</h4><p>我在查找宿主机日志时发现如下信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[3594300.447892] ACPI Exception: AE_AML_BUFFER_LIMIT, Evaluating _PMM (20130517/power_meter-339)</span></div><div class="token-line"><span class="token plain">    [3594360.439864] ACPI Error: SMBus/IPMI/GenericSerialBus write requires Buffer of length 66, found length 32 (20130517/exfield-389)</span></div><div class="token-line"><span class="token plain">    [3594360.439874] ACPI Error: Method parse/execution failed [\_SB_.PMI0._PMM] (Node ffff8801749b05f0), AE_AML_BUFFER_LIMIT (20130517/psparse-536)</span></div></pre></div><p>从错误信息来看，这是一个ACPI缓存区大小的问题。这个缓存大小在BIOS和内核之间没有协商一致，也就是说请求的缓存区大小是66字节，而给的却是32字节。所以，电源监控的管理模块就报了异常。</p><p>这是缺少内核模块引起的，因为这个内核模块在我所用的这个内核版本中不会自动更新。对应的解决方法倒也简单：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">echo &quot;blacklist acpi_power_meter&quot; &gt;&gt; /etc/modprobe.d/hwmon.conf</span></div><div class="token-line"><span class="token plain">    modprobe ipmi_si</span></div><div class="token-line"><span class="token plain">    modprobe acpi_ipmi</span></div></pre></div><p>其中，第一条命令是为了不让这个错误再次出现。当然了，这不是解决问题，只是不想看到这个报错而心里烦燥。后面两条命令是手动加载模块，但前提是你要更新内核版本。</p><h4 id="支线问题二"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#支线问题二"><span class="icon icon-link"></span></a>支线问题二</h4><p>再回到我们分析的主线上，前面提到一个Java的YGC消耗的CPU比较高，但是业务逻辑又没有什么问题。所以，我尝试换一个最简单的Demo程序，先来测试一下整个集体是不是正常的。这个Demo程序没有任何业务逻辑，只返回247B的示例程序。</p><p>我简单说明一下，我之所以把这个测试过程放在这个支线问题中来描述，是想让我的行为更加有条理。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimaged865d8c0cbd80d3b2de6bb1c7a0cca0ea165.6132498e.png" alt=""/></p><p>在这个测试过程中，我执行了两次。上图的前半部分走了Ingress，后面没有走Ingress，可是后面TPS并没有掉下来。这时，问题就基本清楚了。</p><p>我这里列个表格梳理一下到现在看到的信息，理理思路。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage5e915eca82b2dc67e069edbddfc946e8f991.d1399d49.jpg" alt=""/></p><p>从以上数据可以判断出，TPS掉下来和Ingress有绝对的关系。那我们就来看看Ingress的日志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">root@nginx-ingress-m9htx:/var/log/nginx# ls -lrt</span></div><div class="token-line"><span class="token plain">    total 0</span></div><div class="token-line"><span class="token plain">    lrwxrwxrwx 1 root root 12 Sep 10  2019 stream-access.log -&gt; /proc/1/fd/1</span></div><div class="token-line"><span class="token plain">    lrwxrwxrwx 1 root root 12 Sep 10  2019 error.log -&gt; /proc/1/fd/2</span></div><div class="token-line"><span class="token plain">    lrwxrwxrwx 1 root root 12 Sep 10  2019 access.log -&gt; /proc/1/fd/1</span></div><div class="token-line"><span class="token plain">    root@nginx-ingress-m9htx:/proc/1/fd# ls -lrt</span></div><div class="token-line"><span class="token plain">    total 0</span></div><div class="token-line"><span class="token plain">    lrwx------ 1 root root 64 Jan  7 18:00 7 -&gt; &#x27;socket:[211552647]&#x27;</span></div><div class="token-line"><span class="token plain">    lrwx------ 1 root root 64 Jan  7 18:00 4 -&gt; &#x27;anon_inode:[eventpoll]&#x27;</span></div><div class="token-line"><span class="token plain">    lrwx------ 1 root root 64 Jan  7 18:00 3 -&gt; &#x27;socket:[211552615]&#x27;</span></div><div class="token-line"><span class="token plain">    l-wx------ 1 root root 64 Jan  7 18:00 2 -&gt; &#x27;pipe:[211548854]&#x27;</span></div><div class="token-line"><span class="token plain">    l-wx------ 1 root root 64 Jan  7 18:00 1 -&gt; &#x27;pipe:[211548853]&#x27;</span></div><div class="token-line"><span class="token plain">    lrwx------ 1 root root 64 Jan  7 18:00 0 -&gt; /dev/null</span></div><div class="token-line"><span class="token plain">    root@nginx-ingress-m9htx:/proc/1/fd# find ./ -inum 212815739</span></div><div class="token-line"><span class="token plain">    root@nginx-ingress-m9htx:/proc/1/fd# find ./ -inum 212815740</span></div></pre></div><p>悲怆的感觉！你看，日志直接重定向到标准输出和标准错误了，而标准输出和标准错误默认都是屏幕。那我们就到Kubernetes管理工具中去追踪日志。可是，结果是啥也没有。唉，这可怎么办呢？</p><p>从下面这张图我们也可以看到，当压力经过这个Ingress时，报错是必然的，压力越大，报错越多。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimageea3cea69119818e9e0e014c979a137efc23c.b994f039.png" alt=""/></p><p>可是分析到这里，我们再没有其他可以分析的日志了。没什么办法，只能查一下Ingress的版本了，结果发现，当前的Ingress已经有了新的版本。</p><p>为了避免去踩Ingress本身存在的一些坑，我把它的版本从1.5.5换到1.9.1之后，得到如下结果：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage61e961dd625bd75c44e2d2dd1f56678202e9.a30cf490.png" alt=""/></p><p>你看图中没有报错了，看来那些错误是Ingress版本导致的。</p><p>然而，即便如此，我们还是没有解决TPS会掉的问题。你可能会说，上面这张图里的TPS不是没有掉吗？其实，这只是假象。在上面的场景中，我们只是为了验证Ingress的问题，所以，执行时间并不长。</p><p>请你注意，我们到这里并没有解决前面所说的TPS会掉的问题。应该说，我们这里可能有两个问题，一个是Ingress，而另一个可能是在其他地方，但是我们还没有去验证。因此，我们要回到主线上，继续来分析它。</p><h4 id="回到主线"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#回到主线"><span class="icon icon-link"></span></a>回到主线</h4><p>经过一翻折腾，你是不是感觉脑袋已经晕了？当我们被一些技术细节深深拖进去的时候，一定要保持清醒。</p><p>根据我的经验，这个时候我们可以在纸上画一下架构图。并不是说前面已经有架构图，我们就不用画了。画架构图是为了帮我们梳理思路。并且我们还要画得再细一点：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage54a75404ce9653d310167bc0d0b4fabc91a7.adce5c35.jpg" alt=""/></p><p>经过梳理，我采用分段测法来判断问题与哪一层相关：因为Cart服务需要通过外部调用走网关，那我在这里直接调用Cart服务，不走网关。并且我也跳过Ingress，直接用NodePort来提供服务，看看TPS有没有调下来。</p><p>首先，我直接从cart服务的NodePort压进去，得到这样的结果：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage447e445d5c2da479e860ca9813b9f4124a7e.8af8face.png" alt=""/></p><p>也就是说，Cart服务本身就会导致TPS降下来，看起来也并不规律。</p><p>那我们就修改Tomcat参数，把线程数、连接数调大，再来一次。你可能奇怪，为什么要这样调呢？这是因为在查看应用线程健康状态的过程中，我注意到Spring Boot里的Tomcat线程很忙。</p><p>在我这样反复验证了几次之后，发现TPS并没有掉下去。</p><p>为了进一步验证TPS和上面的线程数、连接数等参数有关，我又特意把配置改回去，再看是不是Tomcat参数的问题。</p><p>结果，TPS掉下去的情况没有复现！</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagee51ae5b0fee657d8d6d84f0bc57yy755421a.a59d118d.png" alt=""/></p><p>气得我不得不吃份麻辣烫发泄一下。本来我已经看到了TPS掉下来和GC有关。并且，我们在GC中经过一顿分析发现，Servlet的hashmap$node在快速地创建和回收，说明YGC消耗资源多和压力大小有关，所以调了Tomcat相关的参数。可是，现在在同样的压力下，问题竟然不能复现，也真是醉了。</p><p>像这种随机的问题是比较难整的。不知道TPS稳定的假象是不是和中间有过重启有关。话说重启大法，在技术领域中真是绝对的大招。</p><p>既然这个问题没有复现，现场也没有了，我们也只能放弃。</p><p>虽然针对这个问题，我们从前到后的分析逻辑都非常合理，但是仍然没有找到问题点在哪里。如果它是一个随机的问题，那就是我们没有在合适的时机抓到问题的原因。</p><p>对于一个项目来说，如果出现的随机问题对业务造成的影响是不能接受的，那我们就必须花大精力去解决。如果影响不大，那也可以先放一放。但是每一个问题都有出现的必然性，也就是说，那些看似随机的问题，其实在技术中都有着绝对的必然性。</p><p>那这个问题到底是什么呢？在这里，我先留一个悬念，因为再继续分析下去，我们这节课就太长了，你看着也很累。下节课我们接着分析。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#总结"><span class="icon icon-link"></span></a>总结</h2><p>在这节课中，我们讲了两个阶段的性能分析。</p><p>第一个阶段比较简单，就是一个查询的问题。对于查询来说，在实时交易的过程中，最好能够精准查找。如果出现范围查询，那就必须要有分页。</p><p>不过，如果是大范围的查询，那不仅会对网络造成压力，同时还会对应用、数据库等各层都产生非常明显的压力。所以，在出现范围查询时，我们必须做好技术选型。当业务必须做这样的范围查询时，你可以考虑换组件，像大数据这样的思路就可以用起来了。</p><p>第二个阶段有点麻烦，虽然我们花了很多时间精力，但是到最后没有找到根本原因。不过，我们分析的方向和思路都是没有问题的。</p><p>对于这种看似很随机的问题，在实际的项目中也经常出现。我们分析到最后可能会发现这是一个非常简单的问题，让人气得直跺脚。至于这个问题的根本原因是什么，我们下节课再做说明。</p><p>无论如何，在这节课中，我们仍然把分析的逻辑描述完整了，希望能给到你一些完整的思路。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/04.基准场景/08#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>最后，请你思考一下：</p><ol><li>在实时交易中，如何快速判断数据库的数据量所引发的性能问题？定向分析的证据链是什么？</li><li>如何从CPU使用高定位到GC效率引发的性能问题？</li></ol><p>记得在留言区和我讨论、交流你的想法，每一次思考都会让你更进一步。</p><p>如果你读完这篇文章有所收获，也欢迎你分享给你的朋友，共同学习进步。我们下这节课再见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/高楼的性能工程实战课/04.基准场景/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:47:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect/umi.ded6fefd.js"></script>
  </body>
</html>
