<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>04 | 如何构建性能分析决策树和查找瓶颈证据链？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/高楼的性能工程实战课/02.性能工程的核心理念/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></span><span>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></li><li>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li><li><a href="/blog-architect/高楼的性能工程实战课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/01.开篇词/01"><span>开篇词 | 打破四大认知局限，进阶高级性能工程师</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念">02.性能工程的核心理念</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/01"><span>01 | 性能工程：为什么很多性能测试人员无法对性能结果负责？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/02"><span>02 | 关键概念：性能指标和场景的确定</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/03"><span>03 | 核心分析逻辑：所有的性能分析，靠这七步都能搞定</span></a></li><li><a aria-current="page" class="active" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04"><span>04 | 如何构建性能分析决策树和查找瓶颈证据链？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点">03.性能工程的实践关键点</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/01"><span>05 | 性能方案：你的方案是否还停留在形式上？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/02"><span>06 | 如何抽取出符合真实业务场景的业务模型？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/03"><span>07 | 性能场景的数据到底应该做成什么样子？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/04"><span>08 | 并发、在线和TPS到底是什么关系？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/03.性能工程的实践关键点/05"><span>09 | 如何设计全局和定向监控策略？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景">04.基准场景</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/01"><span>10 | 设计基准场景需要注意哪些关键点？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/02"><span>11 | 打开首页之一：一个案例，带你搞懂基础硬件设施的性能问题</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/03"><span>12 | 打开首页之二：如何平衡利用硬件资源？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/04"><span>13 | 用户登录：怎么判断线程中的Block原因？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/05"><span>14 | 用户信息查询：如何解决网络软中断瓶颈问题？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/06"><span>15 | 查询商品：资源不足有哪些性能表现？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/07"><span>16 | 商品加入购物车：SQL优化和压力工具中的参数分析</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/08"><span>17 | 查询购物车：为什么铺底参数一定要符合真实业务特性？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/09"><span>18 | 购物车信息确定订单：为什么动态参数化逻辑非常重要？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/10"><span>19 | 生成订单信息之一：应用JDBC池优化和内存溢出分析</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/11"><span>20 | 生成订单信息之二：业务逻辑复杂，怎么做性能优化？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/12"><span>21 | 支付前查询订单列表：如何分析优化一个固定的技术组件？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/04.基准场景/13"><span>22 | 支付订单信息：如何高效解决for循环产生的内存溢出？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景">05.容量稳定性异常场景</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/01"><span>23 | 决定容量场景成败的关键因素有哪些？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/02"><span>24 | 容量场景之一：索引优化和Kubernetes资源分配不均衡怎么办？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/03"><span>25 | 容量场景之二：缓存对性能会有什么样的影响？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/04"><span>26 | 稳定性场景之一：怎样搞定业务积累量产生的瓶颈问题？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/05"><span>27 | 稳定性场景之二：怎样搞定磁盘不足产生的瓶颈问题？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/06"><span>28 | 如何确定异常场景的范围和设计逻辑？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/05.容量稳定性异常场景/07"><span>29 | 异常场景：如何模拟不同组件层级的异常？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/06.特别放送">06.特别放送</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/06.特别放送/01"><span>我们这个课程的系统是怎么搭建起来的？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/07.性能结论">07.性能结论</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/07.性能结论/01"><span>30 | 如何确定生产系统配置？</span></a></li><li><a href="/blog-architect/高楼的性能工程实战课/07.性能结论/02"><span>31 | 怎么写出有价值的性能报告？</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/08.结课测试">08.结课测试</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/08.结课测试/01"><span>一套习题，测出你的掌握程度</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/09.结束语">09.结束语</a><ul><li><a href="/blog-architect/高楼的性能工程实战课/09.结束语/01"><span>结束语 | 做真正的性能项目</span></a></li></ul></li><li><a href="/blog-architect/高楼的性能工程实战课/summary">高楼的性能工程实战课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="如何构建性能分析决策树？" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#如何构建性能分析决策树"><span>如何构建性能分析决策树？</span></a></li><li title="收集计数器的实时数据" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#收集计数器的实时数据"><span>收集计数器的实时数据</span></a></li><li title="怎么查找性能瓶颈证据链？" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#怎么查找性能瓶颈证据链"><span>怎么查找性能瓶颈证据链？</span></a></li><li title="全局监控分析" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#全局监控分析"><span>全局监控分析</span></a></li><li title="定向监控分析" data-depth="3"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#定向监控分析"><span>定向监控分析</span></a></li><li title="总结" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04--如何构建性能分析决策树和查找瓶颈证据链"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#04--如何构建性能分析决策树和查找瓶颈证据链"><span class="icon icon-link"></span></a>04 | 如何构建性能分析决策树和查找瓶颈证据链？</h1><p>你好，我是高楼。</p><p>上节课我给你讲了一个完整且固定的性能分析流程——RESAR性能分析七步法，它可以应用在任何性能分析案例中。在这个分析流程中，有两个关键的技术和思路，分别是性能分析决策树和性能瓶颈证据链。这也是我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/355019">02讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中提到的，贯穿整个性能工程的两个重要概念。</p><p>今天这节课，我们一起来看看怎么一步步构建性能分析决策树和查找性能瓶颈证据链。</p><h2 id="如何构建性能分析决策树"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#如何构建性能分析决策树"><span class="icon icon-link"></span></a>如何构建性能分析决策树？</h2><p>实际上，性能分析决策树在性能监控设计和性能瓶颈分析时都会被使用，并且在性能瓶颈分析时，<strong>我们必须要有决策树的思路</strong>。所以，这是我一定要给你描述的步骤。在后面课程的分析中，我们也会大量地用到“性能分析决策树”这个词。</p><p>首先，什么是性能分析决策树呢？</p><blockquote><p>性能分析决策树是包括了系统架构中所有技术组件、所有组件中的模块以及模块对应计数器的完整的结构化树状图。</p></blockquote><p>在这句话中，有三个重要的层级，分别是组件、模块和计数器：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage31273153f75ce3b9691d49bec6024e23c927.3a4ce526.jpg" alt=""/></p><p>在后面的课程中，我也会频繁使用这三个关键词。</p><p>不过，这个关于“性能分析决策树”的定义虽然很合理，但还是会让人感觉抓不住重点，就像看了哲学语句一样。但是IT技术并不是哲学，所以，我们还要把它细化下去。</p><p>构建性能分析决策树是我们了解一个系统非常关键的环节，总体来看，它分为4个步骤。</p><p><strong>第一步：根据系统的架构，罗列出整个系统架构中的组件。</strong></p><p>在我们这个课程搭建的系统中，整体架构的组件是这样的：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimageb722b764098c8f09498805d387d3acbaf422.7d06a2e6.jpg" alt=""/></p><p>对应上面这张图，我们就能罗列出该系统的所有组件，如下：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage7ce97c2833d697db32fefb40f277d993cde9.9e51d9a0.jpg" alt=""/></p><p><strong>第二步：深入细化组件中的每一个重要的模块。</strong></p><p>由于我们这个系统中的组件太多，我们先选择其中一个比较重要的组件——操作系统，来做示例。因为操作系统是性能分析中非常重要的一个环节，几乎所有的问题都会体现到操作系统的计数器上。至于其他的组件，你可以根据我说的流程自行确定一下。</p><p>根据操作系统的特性，我们先画出它的重要模块：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage6de16d1c9ae3b558d6e51885b91f1f6eb6e1.c647796b.jpg" alt=""/></p><p>我在图中画了六个模块，其中一个是Swap。Swap的存在是为了让系统在没有内存可用的时候，可以用硬盘来做内存的交换分区。当Swap被用到时，其实就说明性能已经有了问题。所以，一般不建议在性能项目中使用Swap，我们应该在使用Swap之前就把性能问题解决掉。不过，在生产环境中，如果我们被逼无奈，也只能把Swap打开了。</p><p>至于图中其他几个模块，基本上是我们在性能分析中必须要看的内容。</p><p><strong>第三步：列出模块对应的计数器。</strong></p><p>在罗列计数器的时候，我们要注意把<strong>每个模块重要的计数器都囊括进来，千万不能漏掉重要的第一级计数器</strong>，如果漏掉的话，有些数据可能就需要重新跑了。</p><p>现在，我们来看其中一个重要的模块——CPU。我们可以通过top命令查看到CPU的几个重要的计数器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@k8s-worker-8 ~]# top</span></div><div class="token-line"><span class="token plain">    top - 00:38:51 up 28 days,  4:27,  3 users,  load average: 78.07, 62.23, 39.14</span></div><div class="token-line"><span class="token plain">    Tasks: 275 total,  17 running, 257 sleeping,   1 stopped,   0 zombie</span></div><div class="token-line"><span class="token plain">    %Cpu0  :  4.2 us, 95.4 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.4 st</span></div><div class="token-line"><span class="token plain">    %Cpu1  :  1.8 us, 98.2 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></div><div class="token-line"><span class="token plain">    %Cpu2  :  2.1 us, 97.9 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></div><div class="token-line"><span class="token plain">    %Cpu3  :  1.0 us, 99.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></div></pre></div><p>可以看到，top命令中有九个计数器，分别是：us/sy/ni/id/wa/hi/si/st/load average。前8个是CPU的计数器，这是毋庸置疑的。那最后一个load average是什么呢？</p><p>在搜索引擎上，我们经常能看到一些关于load average的笼统描述。有人说load average高过CPU就说明系统负载高，也有人说load average和CPU并没有直接的关系，观点不一。</p><p>load average作为CPU一个非常重要的性能计数器，我们在用它做判断时，如果不能给出非常明确的判断方向，那就有大问题了。所以，我要给你好好描述一下。</p><blockquote><p>load average是1m/5m/15m内的可运行状态和不可中断状态的平均进程数。</p></blockquote><p>这个说法非常对，但中规中矩，而且不是非常具体。</p><p>对于“可运行状态”，我们比较容易理解。从上面代码块中的数据可以看到，tasks中有一个Running状态的任务数。不过，可运行状态不只是它，还有一些万事俱备只差CPU的情况。也就是说tasks中的Running状态的任务数，与load average的值之间并不是直接的等价关系。</p><p>同样在vmstat中，我们也能看到运行的任务数。在vmstat的proc列有两个参数：r 和 b。其中，r 是指正在运行状态和等待运行状态的进程，在man手册中是这样描述的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">r: The number of runnable processes (running or waiting for run time).</span></div></pre></div><p>对于不可中断状态，我们经常见到的就是等IO。当然，也不止是等IO，内存交换也会在这个状态里，这种等IO的情况会体现在vmstat中proc下面的b列。下面这个计数器就是vmstat的proc的b列的说明。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">b: The number of processes in uninterruptible sleep.</span></div></pre></div><p>所以我们可以看到，<strong>load average实际上就是vmstat中proc列的r与b之和。</strong></p><p>其实，CPU不止有us/sy/ni/id/wa/hi/si/st/load average这九个计数器，它还有两个计数器藏在mpstat中，分别是%guest和%gnice。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[root@k8s-worker-8 ~]# mpstat -P ALL 2</span></div><div class="token-line"><span class="token plain">    Linux 3.10.0-1127.el7.x86_64 (k8s-worker-8) 	2021年02月15日 	_x86_64_	(4 CPU)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    14时00分36秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span></div><div class="token-line"><span class="token plain">    14时00分38秒  all    5.13    0.00    3.21    0.00    0.00    0.26    0.00    0.00    0.00   91.40</span></div><div class="token-line"><span class="token plain">    14时00分38秒    0    4.62    0.00    2.56    0.00    0.00    0.00    0.00    0.00    0.00   92.82</span></div><div class="token-line"><span class="token plain">    14时00分38秒    1    4.57    0.00    3.05    0.00    0.00    0.00    0.00    0.00    0.00   92.39</span></div><div class="token-line"><span class="token plain">    14时00分38秒    2    5.70    0.00    3.63    0.00    0.00    0.00    0.00    0.00    0.00   90.67</span></div><div class="token-line"><span class="token plain">    14时00分38秒    3    5.70    0.00    4.66    0.00    0.00    0.00    0.00    0.00    0.00   89.64</span></div></pre></div><p>从下面这段描述中可以看到，如果在宿主机上看%guest和%gnice这两个参数，是比较有意义的，因为它可以说明Guest虚拟机消耗CPU的比例。如果你的宿主机上有多个虚拟机，你就可以通过这两个参数值来看虚拟机是不是消耗CPU太多，然后通过查进程的方式看看具体是哪一个虚拟机消耗得多。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">%guest Show the percentage of time spent by the CPU or CPUs to run a virtual processor.</span></div><div class="token-line"><span class="token plain">    %gnice Show the percentage of time spent by the CPU or CPUs to run a niced guest.</span></div></pre></div><p>所以，在Linux操作系统中，如果是宿主机，我们就需要看11个计数器。如果是虚拟机的话，看9个计数器（图中前9个）就可以了：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage800f809cef070c881a5d7ef4e31cb8f24f0f.16deb3e4.jpg" alt=""/></p><p>讲到这里，我们已经罗列出与CPU相关的所有计数器了。我们前面提到，要根据Linux操作系统中的各个模块，把相应的计数器全都罗列出来。所以，其他模块的计数器我们也需要像这样完整地找出来。</p><p>当我们把Linux操作系统所有的关键一级计数器找完之后，就会得到这样一张图：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage535053f3f70b3fe256549d9b10d13d599050.566d99e4.jpg" alt=""/></p><p>请你注意，这些计数器里，有一些会比较关键，我根据自己的经验，把重要的计数器都标红了。当然，如果你对操作系统有足够的理解，也可以从不同的角度，用不同的思路，列出自己的图。要知道，罗列计数器只是一个体力活，只要你愿意，就能列出来。</p><p><strong>第四步：画出计数器之间的相关性。</strong></p><p>从上面的图可以看到，尽管我们列出了很多计数器，但是这些计数器之间的关系是什么，我们还不清楚。</p><p>在分析的时候，由于我们要根据相应的计数器，来判断问题的方向（有时候一个计数器并不足以支撑我们作出判断，那我们就需要多个计数器共同判断）。所以，我们要画出这些计数器之间的关系，这一步非常重要。</p><p>我根据自己的理解，画出了Linux操作系统中计数器之间的关系，如下所示：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage32df32a9714095aa2ff0c8002ee7fa2da7df.db36f14b.jpg" alt=""/></p><p>如果线画得太多，看起来会比较混乱，所以我只画出了几个最重要的关键相关性。</p><p>至此，我们就把Linux操作系统的性能分析决策树画完了，计数器也覆盖全了。不过，工作还没有结束，因为我们还需要找到合适的监控工具，来收集这些计数器的实时数据。</p><h3 id="收集计数器的实时数据"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#收集计数器的实时数据"><span class="icon icon-link"></span></a>收集计数器的实时数据</h3><p>请你注意，在收集计数器的实时数据时，可能不是一个监控工具就可以完全覆盖所有的计数器的。所以，在分析的时候，我们一定要清楚监控工具的局限在哪里。如果一个工具无法监控到全部的计数器，那就必须用多个工具相互补充，比如说对于Linux操作系统的监控，现在我们最常用的监控工具就是prometheus+grafana+node_exporter，像这样：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagec911c9c577792a0ce67828223ea00a0c2211.e9322410.png" alt=""/><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagee436e4fe7316655998ab94d73e4ea08f5436.e451e636.png" alt=""/></p><p>这是我们经常用的监控Linux操作系统的模板。那这个模板的数据全不全呢？其实一对比就能发现，这个模板虽然可以覆盖大部分Linux操作系统的性能计数器，但是并不全，比如说网络的队列、内存的软/硬错误等，这些就没有覆盖到。</p><p>因此，<strong>我们在使用监控工具之前，一定要把性能分析决策树中的计数器，与监控工具中的计数器做对比，缺什么，我们就要在分析时用其他的监控工具或是命令来做补充。</strong></p><p>请你记住一点，<strong>用什么监控工具并不重要，有没有监控到全部的计数器才重要</strong>。即便我们没有任何的监控工具，要是只敲命令也能监控到全部计数器的话，也是可以的。所以，我希望你不要迷信工具。</p><p>到这里，整个性能分析决策树还没有结束。因为在这个系统的架构中还有其他的技术组件，而我们的任务就是把这些技术组件，都按照我们前面讲的那四个步骤，画出相应的性能分析决策树，最终形成一张完整的大图。</p><p>在我们这个系统中，如果画出全部的技术组件和模块的话，就会看到下面这张图：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage3c403cdfffda19f49f8af530ee73c500b440.22f7e529.jpg" alt=""/></p><p>整个图我没有全部展开，要是展开的话就太大了，会完全看不到末端的计数器。不过你放心，在后面课程的分析案例中，我会让你看到如何应用这个性能分析决策树来做相应的问题分析。</p><p>讲到这里，我就把性能分析决策树完整地给你描述完了，步骤也列清楚了。古人有云：授人以鱼不如授人以渔。所以，我希望你看到这些步骤之后，可以画出你自己项目中完整的性能分析决策树。</p><p>我还要强调一点，这里我们只列出了第一级的性能计数器。如果第一级计数器有问题，而我们还不能判断出问题的原因，那就需要接着找第二级、第三级、第四级.....关于怎么找更深层级的性能计数器，我会在接下来证据链的部分给你讲解。</p><p>不过，在我们一开始梳理性能分析决策树时，没必要把所有层级的性能计数器都列出来。因为可能我们整个项目做完了，都没有用到全部的计数器，全列出来容易浪费时间。只有我们看懂了第一级的计数器，并且判断出问题的方向，才有可能需要看更深层的计数器。</p><p>所以，<strong>你要注意，理解每个计数器的含义才是至关重要的</strong>。如果不理解计数器的含义，也不知道如何运用计数器，那我们就不可能知道怎么去做分析。</p><p>有了性能分析决策树之后，我们如何应用它呢？接下来，就不得不讲一讲性能瓶颈的证据链了。</p><h2 id="怎么查找性能瓶颈证据链"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#怎么查找性能瓶颈证据链"><span class="icon icon-link"></span></a>怎么查找性能瓶颈证据链？</h2><p>在每次做培训或者性能分析时，我都会强调，性能分析中有一个非常关键的词，那就是“证据链”。</p><p>如果性能分析没有证据链，那么分析思路就是跳跃的。通俗点讲，就是蒙，根据经验蒙，根据资料蒙。这种跳跃的分析思路是非常容易出错的。所以，我们在分析性能瓶颈时，一定要有理有据、顺藤摸瓜。</p><p>那具体怎么来判断呢？接下来我会通过一个例子给你讲解。</p><h3 id="全局监控分析"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#全局监控分析"><span class="icon icon-link"></span></a>全局监控分析</h3><p>在进入这个例子之前，我需要跟你强调一点，在性能分析中，监控分析可以分为两个部分：全局监控分析和定向监控分析。全局监控分析是指将整个架构中具有概括性的计数器都分析一遍。也<strong>只有从全局监控计数器，我们才能看到性能问题的第一层现象</strong>。</p><p>比如说，如果我们想找到哪一行代码有消耗CPU的问题，首先，我们是不知道具体是哪一行代码的，但是在CPU计数器上会体现出CPU使用率高的现象。而全局监控就是为了查看CPU消耗是不是比较高，当我们看到CPU消耗高的时候，再往下找是哪一行代码消耗CPU比较高，这就用到了定向监控分析的思路。</p><p>所以在性能分析的过程中，我通常会分为全局监控分析和定向监控分析两个阶段。而全局监控分析既可以用监控平台，也可以用命令。</p><p>在我之前做过的一个项目中，有一个主机有24颗CPU，我在场景执行过程中看到了这样的数据：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage13e113a47c8ce29f91b791d4f1e5ffeeb4e1.4025b052.png" alt=""/></p><p>这就是我们前面提到的，性能分析决策树中CPU监控的具体命令。所以我们接下来的分析逻辑就是：<strong>根据性能瓶颈的分析应用，选择相应的监控手段，覆盖性能分析决策树中<strong><strong>需要监控的</strong></strong>计数器，<strong><strong>然后</strong></strong>再进一步细化分析。</strong></p><p>在上面这张图中，我们看到所有CPU的%us使用率并没有很高，%id也不小，还有一些剩余。但是%si（软中断）这一项，唯独第22颗CPU的%si有21.4%之高。那这个软中断合理不合理呢？</p><p>有人可能会说，这也没有太高嘛，能有什么问题？如果我们只看%si平均值的话，可能确实发现不了问题的存在。但如果仔细看图中更详细的数据，就会有不一样的结论了，这也是为什么我们要把每颗CPU的使用率都先列出来的原因。</p><p>我们说，当一个应用跑着的时候，如果应用代码消耗了很多CPU，那%us的使用率应该会变高，但是在上面我们看到的并不是%us高。并且在合理的情况下，每个CPU都应该被使用上，也就是说这些CPU的使用率应该是均衡的。</p><p>但是在这个图中，我们看到只有CPU 22的%si使用率比较高，为21.4%。并且软中断（%si）只使用了24颗CPU中的一颗。这个软中断显然是不合理的。</p><h3 id="定向监控分析"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#定向监控分析"><span class="icon icon-link"></span></a>定向监控分析</h3><p>那既然软中断不合理，我们自然是要知道这个软中断到底中断到哪里去了，为什么只中断到一颗CPU上。所以，我们要去查一下软中断的数据。</p><p>在Linux操作系统中，有不少工具可以查看软中断，其中一个重要的工具就是/proc/softirqs。这个文件记录了软中断的数据。在我们这个例子中，因为有24颗CPU，数据看起来实在比较长。所以，我先把一些CPU数据过滤掉了，只留下图中这些数据来分析。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage9e969ed28fded9b2329db013d6100eef1796.2575a25e.png" alt=""/></p><p>在这张图中，我标注出了CPU 22和它对应的模块名NET_RX。你可能会奇怪，怎么一下子就找到了这个模块呢？这是因为CPU 22的使用率最高，在它上面产生的中断数自然要比其他CPU高得多。</p><p>由于 /proc/softirqs文件中的各个计数器都是累加值，其他模块在各个CPU上的累加值比例都没有太大的差别，只有NET_RX模块在不同CPU上的计数值差别很大。所以，我们可以作出这样的判断：CPU 22的使用率高是因为NET_RX。</p><p>我们看“NET_RX”这个名字就能知道，这个模块的意思是网络接收数据。那在网络数据接收的过程中，什么东西会导致网络的中断只中断在一颗CPU上呢？</p><p>我们知道，网络的接收是靠队列来缓存数据的，所以我们接下来得去查一下网络接收的队列有多少个。我们可以通过/sys/class/net/&lt;网卡名&gt;/queues/路径，查看到这个网络队列：<br/><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagea792a724bcd6a30c2ba0fe5d7cfe09eef092.7bbfceb0.png" alt=""/></p><p>不难看出，RX队列确实只有一个，这也就意味着，所有的网络接收数据都得走这一个队列。既然如此，那自然不可能用到更多的CPU，只能用一颗了。</p><p>讲到这里，我要多说明一点：因为我们这节课重在讲解分析的逻辑，所以我在这里就不做更加细致的分析了。如果你要想更深入地理解网络中断逻辑，可以去翻一下Linux源码，看看net_rx_action函数。不过归根到底，中断在系统层的调用都是do_softirqs函数，所以当我们用perf top -g命令查看CPU热点的时候，你同样也可以看到上面我所描述的逻辑。</p><p>既然我们知道了网络接收队列只有一个，那上述问题的解决思路自然也就出来了：多增加几个队列，让更多的CPU来做中断的事情。因为网络中断是为了把数据从网卡向TCP层传输，所以队列一旦变多了，传输速度也会变得快一些。</p><p>所以，我们的解决方案就是增加队列：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage294f29b666e6fda238956313dc9a011daf4f.7bb3056d.png" alt=""/></p><p>在我们这个例子中，我把队列增加到了8个，这样网络接收数据就会用到8颗CPU。如果你想用更多的CPU也可以，这里我们有24颗CPU，那就可以设置24个队列。如果你用的是虚拟机，对于这个改动，你可以在KVM的XML参数中增加一个队列参数来实现；如果你用的是物理机，那你就只能换网卡了。</p><p>现在我们把整个分析逻辑都理清楚了，下面就按照这个逻辑把对应的证据链画一下：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage77857776f9abc8bdd4a004eca72cf446b285.92c402fa.jpg" alt=""/></p><p>根据图中展示的逻辑，当我们看到%si（软中断）高时，就去查看cat/proc/interrupts目录。其实对于这个软中断，有两个目录可以体现出来，一个是cat/proc/interrupts，另一个是cat/proc/softirqs。前者不仅包括软中断，还包括硬中断，如果我们看到软中断高，其实直接看cat/proc/softirqs就可以了。</p><p>紧接着，我们要找到对应的模块，然后再找到这个模块的实现原理，最后我们给出相应的解决方案。</p><p>这样一来，这个问题的完整证据链就找到了。</p><p>相信你通过这个例子可以看出，性能瓶颈的证据链其实就是，性能分析决策树在具体应用过程中完整的分析逻辑的记录。</p><p>请你注意，我们一开始并不会直接去看cat/proc/softirqs的内容，因为这个太定向、太具体了。我们一定要先看全局的数据，然后再一步一步往下去找，这样才是合理的。不难发现，我们从全局监控分析拿到的数据，和从定向监控分析拿到的数据是不一样的，因为它们是不同的角度，这一点你也要格外注意。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>这节课和上节课一起，我把整个分析逻辑总结为：<strong>RESAR性能分析七步法</strong>，这是性能分析方法论中最重要的核心逻辑。不过，这些内容“孤篇盖全唐”的可能性很小，毕竟性能分析涉及到的所有细节无法在短短两节课里尽述。</p><p>所以，我把我认为最重要的部分都给你描述出来了，当你在实际应用时，可以按照这个思路，实现你的性能分析决策树和性能瓶颈证据链。前提是，你要理解你的系统，理解你的架构，并且要理解我给你讲的分析逻辑。</p><p>在这节课中，我为你讲解了两个重要的内容：性能分析决策树的构建，以及性能瓶颈证据链的查找。这是我们在每一个性能问题的分析过程中，都必须经历的。只有把决策树和证据链具体落地，我们才能在性能分析中无往不利。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-architect/高楼的性能工程实战课/02.性能工程的核心理念/04#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>最后，请你思考一下：</p><ol><li>如何构建你自己的性能分析决策树？</li><li>举一个你做过的性能分析中有完整证据链的案例。</li></ol><p>欢迎你在留言区与我交流讨论。当然了，你也可以把这节课分享给你身边的朋友，他们的一些想法或许会让你有更大的收获。我们下节课见！</p><p><strong>关于课程读者群</strong></p><p>点击课程详情页的链接，扫描二维码，就可以加入我们这个课程的读者群哦，希望这里的交流与思维碰撞能帮助你取得更大的进步，期待你的到来～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/高楼的性能工程实战课/02.性能工程的核心理念/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:47:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect/umi.ded6fefd.js"></script>
  </body>
</html>
