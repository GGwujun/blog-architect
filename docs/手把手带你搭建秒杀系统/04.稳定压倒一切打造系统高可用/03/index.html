<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07｜乾坤大挪移：秒杀的削峰和限流 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></span><span>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a aria-current="page" class="active" href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></li><li>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a aria-current="page" class="active" href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/01.开篇词/01"><span>开篇词｜如何设计一个高并发、高可用的秒杀系统？</span></a></li></ul></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/02.前期准备技术选型与环境准备">02.前期准备技术选型与环境准备</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/02.前期准备技术选型与环境准备/01"><span>01｜直面痛点：秒杀系统的挑战和设计原则</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/02.前期准备技术选型与环境准备/02"><span>02｜蓄势待发：秒杀系统架构设计和环境准备</span></a></li></ul></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/03.系统动工码出最简秒杀系统">03.系统动工码出最简秒杀系统</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/03.系统动工码出最简秒杀系统/01"><span>03 | 指日可待：一步一步搭建秒杀系统（上）</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/03.系统动工码出最简秒杀系统/02"><span>04 | 指日可待：一步一步搭建秒杀系统（下）</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用">04.稳定压倒一切打造系统高可用</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/01"><span>05｜勇于担当：秒杀的隔离策略</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/02"><span>06｜谋定后动：秒杀的流量管控</span></a></li><li><a aria-current="page" class="active" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03"><span>07｜乾坤大挪移：秒杀的削峰和限流</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/04"><span>加餐｜高并发场景：如何提升对突发事件的应急处理能力？</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/05"><span>08｜化骨绵掌：降级、热点和容灾处理</span></a></li></ul></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/05.准确无误打造不超卖和公平的秒杀系统">05.准确无误打造不超卖和公平的秒杀系统</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/05.准确无误打造不超卖和公平的秒杀系统/01"><span>09｜御敌国门外：黑产对抗——防刷和风控</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/05.准确无误打造不超卖和公平的秒杀系统/02"><span>10｜不差毫厘：秒杀的库存与限购</span></a></li></ul></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/06.雷令风行性能调优更上一层楼">06.雷令风行性能调优更上一层楼</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/06.雷令风行性能调优更上一层楼/01"><span>11｜高性能优化：物理机极致优化</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/06.雷令风行性能调优更上一层楼/02"><span>12｜高性能优化：单机Java极致优化</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/06.雷令风行性能调优更上一层楼/03"><span>13｜优化番外篇：Vertx介绍及快速入门</span></a></li></ul></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/07.尾声">07.尾声</a><ul><li><a href="/blog-architect/手把手带你搭建秒杀系统/07.尾声/01"><span>14｜百万级流量秒杀系统的关键总结</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/07.尾声/02"><span>结束语｜秒杀系统之上的业务协同思考</span></a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/07.尾声/03"><span>期末测试｜来赴一场满分之约吧！</span></a></li></ul></li><li><a href="/blog-architect/手把手带你搭建秒杀系统/summary">手把手带你搭建秒杀系统</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="流量削峰" data-depth="2"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#流量削峰"><span>流量削峰</span></a></li><li title="验证码和问答题" data-depth="3"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#验证码和问答题"><span>验证码和问答题</span></a></li><li title="消息队列" data-depth="3"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#消息队列"><span>消息队列</span></a></li><li title="限流" data-depth="2"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#限流"><span>限流</span></a></li><li title="demo-nginx网关限流" data-depth="3"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#demo-nginx网关限流"><span>demo-nginx网关限流</span></a></li><li title="demo-web应用层限流" data-depth="3"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#demo-web应用层限流"><span>demo-web应用层限流</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07乾坤大挪移秒杀的削峰和限流"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#07乾坤大挪移秒杀的削峰和限流"><span class="icon icon-link"></span></a>07｜乾坤大挪移：秒杀的削峰和限流</h1><p>你好，我是志东，欢迎和我一起从零打造秒杀系统。</p><p>前面两节课我们讲了秒杀的隔离策略和流量控制，其目的是降低流量的相互耦合和量级，减少对系统的冲击。这节课我们将继续从<strong>技术角度</strong>来讨论秒杀系统的其他高可用手段——削峰和限流，通过削峰，让系统更加稳健。</p><p>削峰填谷概念一开始出现在电力行业，是调整用电负荷的一种措施，在互联网分布式高可用架构的演进过程中，也经常会采用类似的削峰填谷手段来构建稳定的系统。</p><p>削峰的方法有很多，可以通过业务手段来削峰，比如秒杀流程中设置验证码或者问答题环节；也可以通过技术手段削峰，比如采用消息队列异步化用户请求，或者采用限流漏斗对流量进行层层过滤。削峰又分为无损和有损削峰。本质上，<strong>限流是一种有损技术削峰；而引入验证码、问答题以及异步化消息队列可以归为无损削峰。</strong></p><p>我们先来看一下电商平台线上真实场景下的秒杀流量图，因为数据保密的需要，这里我隐去了具体的流量数字。但是，你可以看到这个图有个非常明显的特点，就是毛刺特别大，流量几秒内爬升到峰值，然后马上掉下来。不管是口罩、茅台，还是春运的火车票，都符合这样的流量特点。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage356435dc492a82da8e4bbc0188918dcc7964.b4d58c34.png" alt=""/></p><p>我们现在需要做的就是通过削峰和限流，把这超大的瞬时流量平稳地承接下来，落到秒杀系统里。这就犹如武侠小说里，众人从高塔纵身跳下，张无忌运用乾坤大挪移，把对众人伤害极大的垂直自由落体运动改变为水平运动，使之安然脱险。</p><h2 id="流量削峰"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#流量削峰"><span class="icon icon-link"></span></a>流量削峰</h2><p>前面的章节中，我介绍过秒杀的业务特点是库存少，最终能够抢到商品的人数取决于库存数量，而参与秒杀的人越多，并发数就越高，随之无效请求也就越多。但从业务方的角度来说，肯定是希望有更多的人参与进来，点击“立即秒杀”按钮体验秒杀的乐趣。</p><p>从上面的流量监控图可以看到，在秒杀开始的时刻，会出现巨大的瞬时流量，这个流量对资源的消耗也是巨大且瞬时的。</p><p>一般来说，我们支撑秒杀系统的硬件资源是有限的，它的处理能力是恒定的，当有秒杀活动的时候，很容易繁忙导致请求处理不过来，而没有活动的时候，机器又是低负载运转。但是为了保证用户的秒杀体验，一般情况下我们的处理资源只能按照忙的时候来预估，这会导致资源的一个浪费。这就好比交通存在早高峰和晚高峰的问题，所以有了外牌限行、尾号限行等多种错峰解决方案。</p><p>因此我们需要设计一些<strong>规则</strong>，延缓并发请求，甚至过滤掉无效的请求，让真正可以下单的请求越少越好。总结来说，削峰的本质，一是让服务端处理变得更加平稳，二是节省服务器的机器成本。</p><p>接下来，我们就重点学习几个常用的削峰手段：验证码、问答题、消息队列、分层过滤和限流。顺便看看互联网大厂里都会采用什么样的手段，以及背后的思考逻辑。</p><h3 id="验证码和问答题"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#验证码和问答题"><span class="icon icon-link"></span></a>验证码和问答题</h3><p>在秒杀交易流程中，引入验证码和问答题，有两个目的：一是快速拦截掉部分刷子流量，防止机器作弊，起到防刷的作用；二是平滑秒杀的毛刺请求，延缓并发，对流量进行削峰。</p><p>让用户在秒杀前输入验证码或者做问答题，不同用户的手速有快有慢，这就起到了让1s的瞬时流量平均到30s甚至1分钟的平滑流量中，这样就不需要堆积过多的机器应对1s的瞬时流量了。</p><p>以下是流程图，我来解释一下。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagea76da7e4c6a0af9c9c22db57d24e8910676d.afbe7b2a.jpg" alt=""/></p><p>设计验证码流程，一般是在用户进入详情页时，先判别秒杀活动是否已经开始，如果已经开始，同时秒杀活动也配置了需要校验验证码标识，那么就需要从秒杀系统获取图片验证码，并进行渲染；用户手工输入验证码后，提交给秒杀系统进行验证码校验，如果通过就跳转至秒杀结算页。</p><p>上图增加的红线部分就是引入了验证码的秒杀流程。当然，我这里介绍的，是把验证码功能作为秒杀系统的一个模块了，而大公司一般都会有单独的验证码服务，我们不用自己造轮子，只要进行系统对接就行了。</p><p>下面我简单介绍一下验证码的实现，通过上图得知，验证码服务需提供两个基本的功能：生成验证码和校验验证码。</p><p><strong>生成验证码</strong>**，**先看接口设计如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">POST /seckill/captchas.jpg?skuId=10001</span></div></pre></div><p>对应的后端代码实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">    	 * 生成图片验证码</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	@RequestMapping(value=&quot;/seckill/captchas.jpg&quot;, method=RequestMethod.POST})</span></div><div class="token-line"><span class="token plain">    	@ResponseBody</span></div><div class="token-line"><span class="token plain">    	public SeckillResponse&lt;String&gt; genCaptchas(String skuId, HttpServletRequest request, HttpServletResponse response) {</span></div><div class="token-line"><span class="token plain">            //从cookie中取出user</span></div><div class="token-line"><span class="token plain">            String user = getUserFromCookie(request);</span></div><div class="token-line"><span class="token plain">            //根据skuId和user生成图片</span></div><div class="token-line"><span class="token plain">            BufferedImage img=createCaptchas(user, skuId);</span></div><div class="token-line"><span class="token plain">    		try {</span></div><div class="token-line"><span class="token plain">    			OutputStream out=response.getOutputStream();</span></div><div class="token-line"><span class="token plain">    			ImageIO.write(img, &quot;JPEG&quot;, out);</span></div><div class="token-line"><span class="token plain">    			out.flush();</span></div><div class="token-line"><span class="token plain">    			out.close();</span></div><div class="token-line"><span class="token plain">    			return null; </span></div><div class="token-line"><span class="token plain">    		} catch (IOException e) {</span></div><div class="token-line"><span class="token plain">    			e.printStackTrace();</span></div><div class="token-line"><span class="token plain">    			return SeckillResponse.error(ErrorMsg.SECKILL_FAIL);</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * 生成验证码图片方法</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        public BufferedImage createCaptchas(String user, String skuId) {</span></div><div class="token-line"><span class="token plain">    		int width=90;</span></div><div class="token-line"><span class="token plain">    		int height=40;</span></div><div class="token-line"><span class="token plain">    		BufferedImage img=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);</span></div><div class="token-line"><span class="token plain">    		Graphics graph=img.getGraphics();</span></div><div class="token-line"><span class="token plain">    		graph.setColor(new Color(0xDCDCDC));</span></div><div class="token-line"><span class="token plain">    		graph.fillRect(0, 0, width, height);</span></div><div class="token-line"><span class="token plain">    		Random random=new Random();</span></div><div class="token-line"><span class="token plain">    		//生成验证码</span></div><div class="token-line"><span class="token plain">    		String formula=createFormula(random);</span></div><div class="token-line"><span class="token plain">    		graph.setColor(new Color(0,100,0));</span></div><div class="token-line"><span class="token plain">    		graph.setFont(new Font(&quot;Candara&quot;,Font.BOLD,24));</span></div><div class="token-line"><span class="token plain">    		//将验证码写在图片上</span></div><div class="token-line"><span class="token plain">    		graph.drawString(formula, 8, 24);</span></div><div class="token-line"><span class="token plain">    		graph.dispose();</span></div><div class="token-line"><span class="token plain">    		//计算验证码的值</span></div><div class="token-line"><span class="token plain">    		int vCode=calc(formula);</span></div><div class="token-line"><span class="token plain">    		//将计算结果保存到redis上面去，过期时间1分钟</span></div><div class="token-line"><span class="token plain">    		cacheMgr.set(&quot;CAPTCHA_&quot;+user+&quot;_&quot;+skuId, vCode, 60000);</span></div><div class="token-line"><span class="token plain">    		return img;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	private String createFormula(Random random) {</span></div><div class="token-line"><span class="token plain">    		private static char[]ops=new char[] {&#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;};</span></div><div class="token-line"><span class="token plain">            //生成10以内的随机数</span></div><div class="token-line"><span class="token plain">    		int num1=random.nextInt(10);</span></div><div class="token-line"><span class="token plain">    		int num2=random.nextInt(10);</span></div><div class="token-line"><span class="token plain">    		int num3=random.nextInt(10);</span></div><div class="token-line"><span class="token plain">    		char oper1=ops[random.nextInt(3)];</span></div><div class="token-line"><span class="token plain">    		char oper2=ops[random.nextInt(3)];</span></div><div class="token-line"><span class="token plain">    		String exp=&quot;&quot;+num1+oper1+num2+oper2+num3;</span></div><div class="token-line"><span class="token plain">    		return exp;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private static int calc(String formula) {</span></div><div class="token-line"><span class="token plain">    		try {</span></div><div class="token-line"><span class="token plain">    			ScriptEngineManager manager=new ScriptEngineManager();</span></div><div class="token-line"><span class="token plain">    			ScriptEngine engine=manager.getEngineByName(&quot;JavaScript&quot;);</span></div><div class="token-line"><span class="token plain">    			return (Integer) engine.eval(formula);</span></div><div class="token-line"><span class="token plain">    		}catch(Exception e){</span></div><div class="token-line"><span class="token plain">    			e.printStackTrace();</span></div><div class="token-line"><span class="token plain">    			return 0;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div></pre></div><p>以上是自己生成图片验证码的方式，方便起见，你也可以用Google提供的Kaptcha包生成图片验证码。</p><p>同时，为了让交互更加安全，避免被篡改，我们还可以加入签名机制，后端在返回给前端图片验证码的时候，同时返回一个签名，前端在点击“抢购”按钮的时候，把用户输入的验证码以及签名提交给后端服务进行验证。这个签名可以设计如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">signature=base64(timestamp,md5(timestamp,vCode,skuId,user,randomSalt)</span></div></pre></div><p>这里timestamp取生成验证码vCode时的时间戳，randomSalt可以理解为后端的一个私钥。那么在前面代码的第44行，我们存入Redis的值就要换成这个signature了。</p><p>当前端点击“抢购”按钮时，调用后端服务如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">POST /seckill/settlement.html?skuId=10001&amp;signature=ad6543audhhw13dg&amp;timestamp=1345611143&amp;newCode=54</span></div></pre></div><p>接下来我们看**校验验证码****。**校验的逻辑比较简单，从前端的HTTP请求里，取得skuId、user、signature、timestamp和newCode，首先验证timestamp是否已经过期，然后根据用户输入的验证码内容newCode重新计算签名newSignature，并和Redis里的signature进行比对，比对一致表示验证码校验通过。然后我们需要删掉Redis的内容，避免被重复验证，这样的话一个验证码就只会被验证一次了。</p><h3 id="消息队列"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#消息队列"><span class="icon icon-link"></span></a>消息队列</h3><p>除了验证码和问答题，另一种削峰方式是<strong>异步消息队列</strong>。</p><p>当服务A依赖服务B时，正常情况下服务A会直接通过RPC调用服务B的接口，当服务A调用的流量可控，且服务B的TP99和QPS能满足调用时，这是最简单直接的调用方式，没什么问题，目前大部分的微服务间调用也都是这样做的。</p><p>但是，试想一下，如果服务A的流量非常高（假设10万QPS），远远大于服务B所能支持的能力（假设1万QPS），那么服务B的CPU很快就会升高，TP99也随之变高，最终服务B被服务A的流量冲垮。</p><p>这个时候，消息队列就派上用场了，我们把一步调用的直接紧耦合方式，通过消息队列改造成两步异步调用，让超过服务B范围的流量，暂存在消息队列里，由B根据自己的服务能力来决定处理快慢，这就是通过消息队列进行调用解耦的常见手段。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimageb86cb8f142e7926cd954935497917711ae6c.f8b0e9ef.jpg" alt=""/></p><p>常见的开源消息队列有Kafka、RocketMQ和RabbitMQ等，大厂的基础中间件部门一般也会根据自己公司的业务特点，自研适合自己的MQ系统。对一般的场景来说，我推荐你用RocketMQ，应该能解决你大部分的问题。</p><p>以上是通过MQ进行调用解耦的基本思路，现在我们回到秒杀的场景，看看应该怎么设计呢？请看下图：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage94df944yy258d21de2f70b2acc1f0e217edf.7636fa2c.jpg" alt=""/></p><p>以上红色和蓝色的部分，就是通过消息队列解耦后，详情页系统和秒杀系统各自处理的部分。因为解耦了，所以在第6步下单之后，其实是不知道秒杀结果的，因此在第11步，需要前端定期去查询秒杀结果反馈给用户。而在秒杀系统拉取消息队列进行处理的时候，也有个小技巧，那就是当前面的请求已经把库存消耗光之后，在缓存里设置占位符，让后续的请求快速失败，从而最快地进行响应。</p><h2 id="限流"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#限流"><span class="icon icon-link"></span></a>限流</h2><p>削峰的方式，前面介绍了验证码/问答题以及消息队列，这些方式使流量峰值变得更加平滑，但也在一定程度上降低了抢购体验，容易引发用户咨询和投诉。那有没有更好的解决方式呢？接下来我们学习下限流，看看如何通过限流实现削峰。</p><p>限流是系统自我保护的最直接手段，再厉害的系统，总有所能承载的能力上限，一旦流量突破这个上限，就会引起实例宕机，进而发生系统雪崩，带来灾难性后果。</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/420777">第一讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候，我有和你提到过流量漏斗的概念，对于秒杀流程来说，从用户开始参与秒杀，到秒杀成功支付完成，实际上经历了很多的系统链路调用，中间有非常庞杂的系统在支撑，比如有商详、风控、登录、限购、购物车以及订单等很多交易系统。</p><p>那么对于秒杀的瞬时流量，如果不加筛选，不做限制，直接把流量传递给下游各个系统，对整个交易系统都是非常大的挑战，也是很大的资源浪费，所以主流的做法是从上游开始，对流量进行逐级限流，分层过滤，优质的有效的流量最终才能参与下单。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagee8cde8e9d01c9e384c8eb7ee6bc908901dcd.ac6add42.jpg" alt=""/></p><p>这是系统的<strong>流量漏斗示意图</strong>，通过风控和防刷筛选刷子流量，通过限购和预约校验过滤无效流量，通过限流丢弃多余流量，最终秒杀系统给到下游的流量就是非常优质且少量的了。</p><p>限流常用的算法有令牌桶和漏桶，有关这两个算法的专业介绍，你可以参考：<a target="_blank" rel="noopener noreferrer" href="https://hansliu.com/posts/2020/11/what-is-token-bucket-and-leaky-bucket-algorithms.html">https://hansliu.com/posts/2020/11/what-is-token-bucket-and-leaky-bucket-algorithms.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimagefb69fb564594bb1bb523dde77b678822c269.435cca52.jpg" alt=""/></p><p>下面我们针对demo-nginx和demo-web两个应用，介绍一下具体的限流方法。</p><h3 id="demo-nginx网关限流"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#demo-nginx网关限流"><span class="icon icon-link"></span></a><strong>demo-nginx网关限流</strong></h3><p>先开始<strong>准备工作</strong>，俗话说，工欲善其事必先利其器，在开发之前，我们先把Nginx的日志给配置起来，方便我们后续开发的调试与验证。</p><p>Nginx日志配置：Nginx主要有两种类型的日志文件。</p><p>一个是error_log，用来记录我们的系统日志，以及主动打印的业务日志，配置语法为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">error_log &lt;日志文件路径&gt; &lt;日志级别&gt;;</span></div></pre></div><p>另一个是access_log，这个日志主要用来记录我们的请求和返回相关的信息，配置语法为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">access_log &lt;日志文件路径&gt; &lt;日志格式定义的名称&gt;;</span></div></pre></div><p>如果想自定义输出日志格式，需要使用log_format来实现，下面我们就来配置一下这两种日志。</p><p>首先我们在nginx.conf中定义一个名为access的日志格式，如下图所示：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage75b375a292b5508576f439fa7888c2c3e9b3.79f74eda.png" alt="图片"/></p><p>然后在domain.com中配置error_log和access_log，如下图所示：</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage123912f71dfa20538527c923591ff6595639.21a162ed.jpg" alt="图片"/></p><p>这里我使用了内置变量以及自定义变量$user_id（通过set_by_lua_block定义并赋值）。现在我们已经把日志配置好了，接下来就开始今天的重头戏吧，就从Nginx限流开始讲起。</p><p>这里的Nginx限流，主要是依赖Nginx自带的限流功能，针对请求的来源IP或者自定义的一个关键参数来做限流，比如用户ID。其配置限流规则的语法为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">limit_req_zone &lt;变量名&gt; zone=&lt;限流规则名称&gt;:&lt;内存大小&gt; rate=&lt;速率阈值&gt;r/s;</span></div></pre></div><p>解释一下：</p><ul><li>以上limit_req_zone是关键字，&lt;变量名&gt;是指定根据什么来限流；</li><li>zone是关键字，&lt;限流规则名称&gt;是定义规则名称，后续代码中可以指定使用哪个规则；</li><li>&lt;内存大小&gt;是指声明多大内存来支撑限流的功能；</li><li>rate是关键字，可以指定限流的阈值，单位r/s意为每秒允许通过的请求，这个算法是使用令牌漏桶的思想来实现的。</li></ul><p>那么明白了语法之后，下面我们就<strong>动手定义一个限流规则</strong>，看看实际效果。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">http {</span></div><div class="token-line"><span class="token plain">        limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; </span></div><div class="token-line"><span class="token plain">        server {</span></div><div class="token-line"><span class="token plain">            location /search/ {</span></div><div class="token-line"><span class="token plain">                limit_req zone=one burst=2 nodelay;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上是基于IP地址进行限流的例子，你可以根据实际的情况调整rate和burst的值，在秒杀的场景下，一般我们会把rate和burst设置的很低，可以都为1，即要求1个IP1秒内只能访问1次。</p><p>但根据IP地址设置限流时要慎重，会存在误杀的情况，特别像公司内用户，他们的出口IP就那么几个，很容易就触发了限流，所以我一般在参与阿里、苏宁或京东的秒杀活动时，都会切换到4G网络，避免用公司网络。</p><p>除了基于IP限流外，我们还可以设计基于用户的userId进行限流。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">limit_req_zone $user_id zone=limit_by_user:10m rate=1r/s;</span></div></pre></div><h3 id="demo-web应用层限流"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#demo-web应用层限流"><span class="icon icon-link"></span></a><strong>demo-web应用层限流</strong></h3><p>以上是Nginx网关层的限流，接下来我们进入应用层的限流。应用层的限流手段也是比较多的，这里我们重点介绍通过线程池和API限流的方法。</p><p><strong>线程池限流</strong></p><p>Java原生的线程池原理相信你非常清楚，我们可以通过自定义线程池，配置最大连接数，以请求处理队列长度以及拒绝策略等参数来达到限流的目的。当处理队列满，而且最大线程都在处理时，多余的请求就会被拒绝策略丢弃，也就是被限流了。</p><p><img src="/blog-architect/static/httpsstatic001geekbangorgresourceimage7f567f30154bdbc6d9f085dc92bde0216856.4daacf7b.jpg" alt=""/></p><p><strong>API限流</strong></p><p>上面介绍的线程池限流可以看做是一种并发数限流，对于并发数限流来说，实际上服务提供的QPS能力是和后端处理的响应时长有关系的，在并发数恒定的情况下，TP99越低，QPS就越高。</p><p>然而大部分情况是，我们希望根据QPS多少来进行限流，这时就不能用线程池策略了。不过，我们可以用Google提供的RateLimiter开源包，自己手写一个基于令牌桶的限流注解和实现，在业务API代码里使用。当然了，大厂中都会有通用的限流机制，你直接用就行了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**	</span></div><div class="token-line"><span class="token plain">     * 自定义注解  限流	</span></div><div class="token-line"><span class="token plain">     */	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Target({ElementType.PARAMETER, ElementType.METHOD})	</span></div><div class="token-line"><span class="token plain">    @Retention(RetentionPolicy.RUNTIME)	</span></div><div class="token-line"><span class="token plain">    @Documented	</span></div><div class="token-line"><span class="token plain">    public @interface MyRateLimit {	</span></div><div class="token-line"><span class="token plain">         String description() default &quot;&quot;;	</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们自定义一个切面：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**	</span></div><div class="token-line"><span class="token plain">     * 限流 AOP	</span></div><div class="token-line"><span class="token plain">     */	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Component	</span></div><div class="token-line"><span class="token plain">    @Scope	</span></div><div class="token-line"><span class="token plain">    @Aspect	</span></div><div class="token-line"><span class="token plain">    public class LimitAspect {	</span></div><div class="token-line"><span class="token plain">        //引用RateLimiter，内部是基于令牌桶实现的	</span></div><div class="token-line"><span class="token plain">        private static RateLimiter rateLimiter = RateLimiter.create(100.0);	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //定义限流注解的pointcut	</span></div><div class="token-line"><span class="token plain">        @Pointcut(&quot;@annotation(com.ecommerce.seckill.aop.MyRateLimit)&quot;)  	</span></div><div class="token-line"><span class="token plain">        public void MyRateLimitAspect() {	</span></div><div class="token-line"><span class="token plain">        }	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Around(&quot;MyRateLimitAspect()&quot;)	</span></div><div class="token-line"><span class="token plain">        public  Object around(ProceedingJoinPoint joinPoint) { 	</span></div><div class="token-line"><span class="token plain">            Boolean flag = rateLimiter.tryAcquire();	</span></div><div class="token-line"><span class="token plain">            Object obj = null;	</span></div><div class="token-line"><span class="token plain">            try {	</span></div><div class="token-line"><span class="token plain">                if(flag){	</span></div><div class="token-line"><span class="token plain">                    obj = joinPoint.proceed();	</span></div><div class="token-line"><span class="token plain">                }	</span></div><div class="token-line"><span class="token plain">            } catch (Throwable e) {	</span></div><div class="token-line"><span class="token plain">                e.printStackTrace();	</span></div><div class="token-line"><span class="token plain">            }	</span></div><div class="token-line"><span class="token plain">            return obj;	</span></div><div class="token-line"><span class="token plain">        }	</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>业务层代码实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override	</span></div><div class="token-line"><span class="token plain">    @MyRateLimit	</span></div><div class="token-line"><span class="token plain">    @Transactional	</span></div><div class="token-line"><span class="token plain">    public SeckillResponse initData(String skuId, String userName) {	</span></div><div class="token-line"><span class="token plain">        //此次为业务代码实现	</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课我们介绍了削峰的多种手段，有验证码、问答题、消息队列以及限流等。实际上，这些削峰的方式都可以达到控制流量的目的，你可以根据自己的情况进行选择。</p><p>验证码是一种非常常见的防刷手段，大多数网站的登录模块中，为避免被机器人刷，都会加入图片验证码。而在秒杀系统中，我们除了用验证码来防刷外，还有一个目的就是通过验证码进行削峰，达到流量整形的目的。除了图片验证码，你一定也见过短信和语音验证码，那为什么在秒杀系统的削峰中，我们通常会选择图片验证码呢？主要还是出于成本和用户体验的考虑。</p><p>消息队列是常用的应用解耦方式，通过把同步调用改造成异步消息，消费方可以根据自己的能力来处理请求，而不用担心被瞬时流量打垮。当然了，如果库存已经卖完，那么消费方在处理请求的时候，可以快速失败，这样也不用担心消息的长期积压。</p><p>最后，我介绍了几种限流的方式，和其他削峰方式相比，限流是有损的。限流实际上是根据服务自身的容量，无差别地丢弃多余流量，对于被丢弃的流量来说，这块的体验是受损的。另外，因为秒杀流量会经历很多交易系统，所以我们在设计时需要从起始流量开始，分层过滤，逐级限流，这样流量在最后的下单环节就是少量而可控的了。</p><p>另外，在这一节课开始的时候，我有留下一个小伏笔，就是在介绍了各种削峰手段后，互联网大厂在实践中一般都是怎么选择的呢？其实，如果你去体验下像天猫、京东的秒杀，就会发现他们总体是比较类似的，基本不会使用验证码或答题这两种方式，因为对于头部电商平台来说，体验可能不是那么友好。他们比较偏向采用非公平的抢购策略，也就是有损的逐级限流和分层过滤，背后最重要的考虑其实就是兼顾了体验与系统资源。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>我们在介绍削峰手段的时候，有提到过问答题也是一种削峰方式，但是在这一讲中，因为不常用的关系，我略去了问答题的设计。这里我想请你思考一下，如果让你来设计秒杀的问答题系统，将其作为一种削峰方式，你会怎么设计呢？</p><p>以上就是这节课的全部内容，欢迎你在评论区和我讨论问题，交流经验！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/手把手带你搭建秒杀系统/04.稳定压倒一切打造系统高可用/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:47:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect/umi.ded6fefd.js"></script>
  </body>
</html>
