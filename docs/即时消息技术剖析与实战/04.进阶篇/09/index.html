<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>21 | 期末实战：为你的简约版IM系统，加上功能 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/即时消息技术剖析与实战/04.进阶篇/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></span><span>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a aria-current="page" class="active" href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-architect/spark性能调优实战">spark性能调优实战</a></li></ul></li><li>架构师<ul><li><a href="/blog-architect/设计模式之美">设计模式之美</a></li><li><a href="/blog-architect/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-architect/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-architect/说透中台">说透中台</a></li><li><a href="/blog-architect/oauth2.0实战课">oauth2.0实战课</a></li><li><a href="/blog-architect/从0开始学架构">从0开始学架构</a></li><li><a aria-current="page" class="active" href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/如何设计一个秒杀系统">如何设计一个秒杀系统</a></li><li><a href="/blog-architect/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-architect/性能优化高手课">性能优化高手课</a></li><li><a href="/blog-architect/性能工程高手课">性能工程高手课</a></li><li><a href="/blog-architect/手把手带你搭建秒杀系统">手把手带你搭建秒杀系统</a></li><li><a href="/blog-architect/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-architect/推荐系统三十六式">推荐系统三十六式</a></li><li><a href="/blog-architect/检索技术核心20讲">检索技术核心20讲</a></li><li><a href="/blog-architect/软件设计之美">软件设计之美</a></li><li><a href="/blog-architect/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-architect/高楼的性能工程实战课">高楼的性能工程实战课</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect/即时消息技术剖析与实战">即时消息技术剖析与实战</a></li><li><a href="/blog-architect/即时消息技术剖析与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect/即时消息技术剖析与实战/01.开篇词/01"><span>开篇词 | 搞懂“实时交互”的IM技术，将会有什么新机遇？</span></a></li></ul></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇">02.基础篇</a><ul><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/01"><span>01 | 架构与特性：一个完整的IM系统是怎样的？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/02"><span>02 | 消息收发架构：为你的App，加上实时通信功能</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/03"><span>03 | 轮询与长连接：如何解决消息的实时到达问题？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/04"><span>04 | ACK机制：如何保证消息的可靠投递？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/05"><span>05 | 消息序号生成器：如何保证你的消息不会乱序？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/06"><span>06 | HttpDNS和TLS：你的消息聊天真的安全吗？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/07"><span>07 | 分布式锁和原子性：你看到的未读消息提醒是真的吗？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/02.基础篇/08"><span>08 | 智能心跳机制：解决网络的不确定性</span></a></li></ul></li><li><a href="/blog-architect/即时消息技术剖析与实战/03.场景篇">03.场景篇</a><ul><li><a href="/blog-architect/即时消息技术剖析与实战/03.场景篇/01"><span>09 | 分布式一致性：让你的消息支持多终端漫游</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/03.场景篇/02"><span>10 | 自动智能扩缩容：直播互动场景中峰值流量的应对</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/03.场景篇/03"><span>11 | 期中实战：动手写一个简易版的IM系统</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/03.场景篇/04"><span>12 | 服务高可用：保证核心链路稳定性的流控和熔断机制</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇">04.进阶篇</a><ul><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/01"><span>13 | HTTP Tunnel：复杂网络下消息通道高可用设计的思考</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/02"><span>14 | 分片上传：如何让你的图片、音视频消息发送得更快？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/03"><span>15 | CDN加速：如何让你的图片、视频、语音消息浏览播放不卡？</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/04"><span>16 | APNs：聊一聊第三方系统级消息通道的事</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/05"><span>17 | Cache：多级缓存架构在消息系统中的应用</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/06"><span>18 | Docker容器化：说一说IM系统中模块水平扩展的实现</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/07"><span>19 | 端到端Trace：消息收发链路的监控体系搭建</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/08"><span>20 | 存储和并发：万人群聊系统设计中的几个难点</span></a></li><li><a aria-current="page" class="active" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09"><span>21 | 期末实战：为你的简约版IM系统，加上功能</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/10"><span>22 | 答疑解惑：不同即时消息场景下架构实现上的异同</span></a></li></ul></li><li><a href="/blog-architect/即时消息技术剖析与实战/05.结束语">05.结束语</a><ul><li><a href="/blog-architect/即时消息技术剖析与实战/05.结束语/01"><span>结束语 | 真正的高贵，不是优于别人，而是优于过去的自己</span></a></li><li><a href="/blog-architect/即时消息技术剖析与实战/05.结束语/02"><span>结课测试 | “即时消息技术剖析与实战”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-architect/即时消息技术剖析与实战/summary">即时消息技术剖析与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="功能介绍" data-depth="2"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#功能介绍"><span>功能介绍</span></a></li><li title="功能实现拆解" data-depth="2"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#功能实现拆解"><span>功能实现拆解</span></a></li><li title="WebSocket长连接" data-depth="3"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#websocket长连接"><span>WebSocket长连接</span></a></li><li title="核心消息收发逻辑处理" data-depth="3"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#核心消息收发逻辑处理"><span>核心消息收发逻辑处理</span></a></li><li title="消息推送的ACK" data-depth="3"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#消息推送的ack"><span>消息推送的ACK</span></a></li><li title="应用层心跳" data-depth="3"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#应用层心跳"><span>应用层心跳</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#小结"><span>小结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="21--期末实战为你的简约版im系统加上功能"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#21--期末实战为你的简约版im系统加上功能"><span class="icon icon-link"></span></a>21 | 期末实战：为你的简约版IM系统，加上功能</h1><p>你好，我是袁武林。</p><p>在期中实战中，我们一起尝试实现了一个简易版的聊天系统，并且为这个聊天系统增加了一些基本功能。比如，用户登录、简单的文本消息收发、消息存储设计、未读数提示、消息自动更新等。</p><p>但是期中实战的目的，主要是让你对IM系统的基本功能构成有一个直观的了解，所以在功能的实现层面上比较简单。比如针对消息的实时性，期中采用的是基于HTTP短轮询的方式来实现。</p><p>因此，在期末实战中，我们主要的工作就是针对期中实战里的消息收发来进行功能优化。</p><p>比如，我们会采用WebSocket的长连接，来替代之前的HTTP短轮询方式，并且会加上一些课程中有讲到的相对高级的功能，如应用层心跳、ACK机制等。</p><p>希望通过期末整体技术实现上的升级，你能更深刻地体会到IM系统升级前后，对使用方和服务端压力的差异性。相应的示例代码我放在了<a target="_blank" rel="noopener noreferrer" href="https://github.com/coldwalker/Sample">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里，你可以作为参考来学习和实现。</p><h2 id="功能介绍"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#功能介绍"><span class="icon icon-link"></span></a>功能介绍</h2><p>关于这次期末实战，希望你能够完成的功能主要包括以下几个部分：</p><ol><li>支持基于WebSocket的长连接。</li><li>消息收发均通过长连接进行通信。</li><li>支持消息推送的ACK机制和重推机制。</li><li>支持客户端的心跳机制和双端的idle超时断连。</li><li>支持客户端断线后的自动重连。</li></ol><h2 id="功能实现拆解"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#功能实现拆解"><span class="icon icon-link"></span></a>功能实现拆解</h2><p>接下来，我们就针对以上这些需要升级的功能和新增的主要功能，来进行实现上的拆解。</p><h3 id="websocket长连接"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#websocket长连接"><span class="icon icon-link"></span></a>WebSocket长连接</h3><p>首先，期末实战一个比较大的改变就是，将之前HTTP短轮询的实现，改造成真正的长连接。为了方便Web端的演示，这里我建议你可以使用WebSocket来实现。</p><p>对于WebSocket，我们在客户端JS（JavaScript）里主要是使用HTML5的原生API来实现，其核心的实现代码部分如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (window.WebSocket) {</span></div><div class="token-line"><span class="token plain">        websocket = new WebSocket(&quot;ws://127.0.0.1:8080&quot;);</span></div><div class="token-line"><span class="token plain">        websocket.onmessage = function (event) {</span></div><div class="token-line"><span class="token plain">            onmsg(event);</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //连接建立后的事件监听</span></div><div class="token-line"><span class="token plain">        websocket.onopen = function () {</span></div><div class="token-line"><span class="token plain">            bind();</span></div><div class="token-line"><span class="token plain">            heartBeat.start();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //连接关闭后的事件监听</span></div><div class="token-line"><span class="token plain">        websocket.onclose = function () {</span></div><div class="token-line"><span class="token plain">            reconnect();</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //连接出现异常后的事件监听</span></div><div class="token-line"><span class="token plain">        websocket.onerror = function () {</span></div><div class="token-line"><span class="token plain">            reconnect();</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">        alert(&quot;您的浏览器不支持WebSocket协议！&quot;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>页面打开时，JS先通过服务端的WebSocket地址建立长连接。要注意这里服务端连接的地址是ws://开头的，不是<a target="_blank" rel="noopener noreferrer" href="http:///%E7%9A%84%E4%BA%86%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%98%AF%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E7%9A%84WebSocket%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%82%A3%E4%B9%88%E7%9B%B8%E5%BA%94%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BA%94%E8%AF%A5%E6%98%AF%E4%BB%A5wss://%E5%BC%80%E5%A4%B4%E7%9A%84%E3%80%82">http://的了；如果是使用加密的WebSocket协议，那么相应的地址应该是以wss://开头的。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>建立长连之后，要针对创建的WebSocket对象进行事件的监听，我们只需要在各种事件触发的时候，进行对应的逻辑处理就可以了。</p><p>比如，API主要支持的几种事件有：长连接通道建立完成后，通过onopen事件来进行用户信息的上报绑定；通过onmessage事件，对接收到的所有该连接上的数据进行处理，这个也是我们最核心的消息推送的处理逻辑；另外，在长连接通道发生异常错误，或者连接被关闭时，可以分别通过onerror和onclose两个事件来进行监听处理。</p><p>除了通过事件监听，来对长连接的状态变化进行逻辑处理外，我们还可以通过这个WebSocket长连接，向服务器发送数据（消息）。这个功能在实现上也非常简单，你只需要调用WebSocket对象的send方法就OK了。</p><p>通过长连接发送消息的代码设计如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var sendMsgJson = &#x27;{ &quot;type&quot;: 3, &quot;data&quot;: {&quot;senderUid&quot;:&#x27; + sender_id + &#x27;,&quot;recipientUid&quot;:&#x27; + recipient_id + &#x27;, &quot;content&quot;:&quot;&#x27; + msg_content + &#x27;&quot;,&quot;msgType&quot;:1  }}&#x27;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    websocket.send(sendMsgJson);</span></div></pre></div><p>此外，针对WebSocket在服务端的实现，如果你是使用JVM（Java Virtual Machine，Java虚拟机）系列语言的话，我推荐你使用比较成熟的Java NIO框架Netty来做实现。</p><p>因为Netty本身对WebSocket的支持就很完善了，各种编解码器和WebSocket的处理器都有，这样我们在代码实现上就比较简单。</p><p>采用Netty实现WebSocket Server的核心代码，你可以参考下面的示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">EventLoopGroup bossGroup =</span></div><div class="token-line"><span class="token plain">                        new EpollEventLoopGroup(serverConfig.bossThreads, new DefaultThreadFactory(&quot;WebSocketBossGroup&quot;, true));</span></div><div class="token-line"><span class="token plain">                        </span></div><div class="token-line"><span class="token plain">    EventLoopGroup workerGroup =</span></div><div class="token-line"><span class="token plain">                        new EpollEventLoopGroup(serverConfig.workerThreads, new DefaultThreadFactory(&quot;WebSocketWorkerGroup&quot;, true));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ServerBootstrap serverBootstrap = new ServerBootstrap().group(bossGroup, workerGroup).channel(EpollServerSocketChannel.class);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ChannelInitializer&lt;SocketChannel&gt; initializer = new ChannelInitializer&lt;SocketChannel&gt;() {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        protected void initChannel(SocketChannel ch) throws Exception {</span></div><div class="token-line"><span class="token plain">            ChannelPipeline pipeline = ch.pipeline();</span></div><div class="token-line"><span class="token plain">            //先添加WebSocket相关的编解码器和协议处理器</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(new HttpServerCodec());</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(new HttpObjectAggregator(65536));</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;, null, true));</span></div><div class="token-line"><span class="token plain">            //再添加服务端业务消息的总处理器</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(websocketRouterHandler);</span></div><div class="token-line"><span class="token plain">            //服务端添加一个idle处理器，如果一段时间Socket中没有消息传输，服务端会强制断开</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(new IdleStateHandler(0, 0, serverConfig.getAllIdleSecond()));</span></div><div class="token-line"><span class="token plain">            pipeline.addLast(closeIdleChannelHandler);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    serverBootstrap.childHandler(initializer);</span></div><div class="token-line"><span class="token plain">    serverBootstrap.bind(serverConfig.port).sync(</span></div></pre></div><p>首先<strong>创建服务器的ServerBootstrap对象</strong>。Netty作为服务端，从ServerBootstrap启动，ServerBootstrap对象主要用于在服务端的某一个端口进行监听，并接受客户端的连接。</p><p>接着，<strong>通过ChannelInitializer对象，初始化连接管道中用于处理数据的各种编解码器和业务逻辑处理器</strong>。比如这里，我们就需要添加为了处理WebSocket协议相关的编解码器，还要添加服务端接收到客户端发送的消息的业务逻辑处理器，并且还加上了用于通道idle超时管理的处理器。</p><p>最后，<strong>把这个管道处理器链挂到ServerBootstrap，再通过bind和sync方法，启动ServerBootstrap的端口进行监听</strong>就可以了。</p><h3 id="核心消息收发逻辑处理"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#核心消息收发逻辑处理"><span class="icon icon-link"></span></a>核心消息收发逻辑处理</h3><p>建立好WebSocket长连接后，我们再来看一下最核心的消息收发是怎么处理的。</p><p>刚才讲到，客户端发送消息的功能，在实现上其实比较简单。我们只需要通过WebSocket对象的send方法，就可以把消息通过长连接发送到服务端。</p><p>那么，下面我们就来看一下服务端接收到消息后的逻辑处理。</p><p>核心的代码逻辑在WebSocketRouterHandler这个处理器中，消息接收处理的相关代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {</span></div><div class="token-line"><span class="token plain">        //如果是文本类型的WebSocket数据</span></div><div class="token-line"><span class="token plain">        if (frame instanceof TextWebSocketFrame) {</span></div><div class="token-line"><span class="token plain">            //先解析出具体的文本数据内容</span></div><div class="token-line"><span class="token plain">            String msg = ((TextWebSocketFrame) frame).text();</span></div><div class="token-line"><span class="token plain">            //再用JSON来对这些数据内容进行解析</span></div><div class="token-line"><span class="token plain">            JSONObject msgJson = JSONObject.parseObject(msg);</span></div><div class="token-line"><span class="token plain">            int type = msgJson.getIntValue(&quot;type&quot;);</span></div><div class="token-line"><span class="token plain">            JSONObject data = msgJson.getJSONObject(&quot;data&quot;);</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            long senderUid = data.getLong(&quot;senderUid&quot;);</span></div><div class="token-line"><span class="token plain">            long recipientUid = data.getLong(&quot;recipientUid&quot;);</span></div><div class="token-line"><span class="token plain">            String content = data.getString(&quot;content&quot;);</span></div><div class="token-line"><span class="token plain">            int msgType = data.getIntValue(&quot;msgType&quot;);</span></div><div class="token-line"><span class="token plain">            //调用业务层的Service来进行真正的发消息逻辑处理</span></div><div class="token-line"><span class="token plain">            MessageVO messageContent = messageService.sendNewMsg(senderUid, recipientUid, content, msgType);</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            if (messageContent != null) {</span></div><div class="token-line"><span class="token plain">                JSONObject jsonObject = new JSONObject();</span></div><div class="token-line"><span class="token plain">                jsonObject.put(&quot;type&quot;, 3);</span></div><div class="token-line"><span class="token plain">                jsonObject.put(&quot;data&quot;, JSONObject.toJSON(messageContent));</span></div><div class="token-line"><span class="token plain">                            ctx.writeAndFlush(new TextWebSocketFrame(JSONObject.toJSONString(jsonObject)));</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里的WebSocketRouterHandler，我们也是采用事件监听机制来实现。由于这里需要处理“接收到”的消息，所以我们只需要实现channelRead0方法就可以。</p><p>在前面的管道处理器链中，因为添加了WebSocket相关的编解码器，所以这里的WebSocketRouterHandler接收到的都是WebSocketFrame格式的数据。</p><p>接下来，我们从WebSocketFrame格式的数据中，解析出文本类型的收发双方UID和发送内容，就可以调用后端业务模块的发消息功能，来进行最终的发消息逻辑处理了。</p><p>最后，把需要返回给消息发送方的客户端的信息，再通过writeAndFlush方法写回去，就完成消息的发送。</p><p>不过，以上的代码只是处理消息的发送，那么针对消息下推的逻辑处理又是如何实现的呢？</p><p>刚刚讲到，客户端发送的消息，会通过后端业务模块来进行最终的发消息逻辑处理，这个处理过程也包括消息的推送触发。</p><p>因此，我们可以在messageService.sendNewMsg方法中，等待消息存储、未读变更都完成后，再处理待推送给接收方的消息。</p><p>你可以参考下面的核心代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static final ConcurrentHashMap&lt;Long, Channel&gt; userChannel = new ConcurrentHashMap&lt;&gt;(15000);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {</span></div><div class="token-line"><span class="token plain">            //处理上线请求</span></div><div class="token-line"><span class="token plain">            long loginUid = data.getLong(&quot;uid&quot;);</span></div><div class="token-line"><span class="token plain">            userChannel.put(loginUid, ctx.channel());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    public void pushMsg(long recipientUid, JSONObject message) {</span></div><div class="token-line"><span class="token plain">        Channel channel = userChannel.get(recipientUid);</span></div><div class="token-line"><span class="token plain">        if (channel != null &amp;&amp; channel.isActive() &amp;&amp; channel.isWritable()) {</span></div><div class="token-line"><span class="token plain">            channel.writeAndFlush(new TextWebSocketFrame(message.toJSONString()));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先，我们在处理用户建连上线的请求时，会先在网关机内存记录一个“当前连接用户和对应的连接”的映射。</p><p>当系统有消息需要推送时，我们通过查询这个映射关系，就能找到对应的连接，然后就可以通过这个连接，将消息下推下去。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class NewMessageListener implements MessageListener {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onMessage(Message message, byte[] pattern) {</span></div><div class="token-line"><span class="token plain">            String topic = stringRedisSerializer.deserialize(message.getChannel());</span></div><div class="token-line"><span class="token plain">            //从订阅到的Redis的消息里解析出真正需要的业务数据</span></div><div class="token-line"><span class="token plain">            String jsonMsg = valueSerializer.deserialize(message.getBody());</span></div><div class="token-line"><span class="token plain">            logger.info(&quot;Message Received --&gt; pattern: {}，topic:{}，message: {}&quot;, new String(pattern), topic, jsonMsg);</span></div><div class="token-line"><span class="token plain">            JSONObject msgJson = JSONObject.parseObject(jsonMsg);</span></div><div class="token-line"><span class="token plain">            //解析出消息接收人的UID</span></div><div class="token-line"><span class="token plain">            long otherUid = msgJson.getLong(&quot;otherUid&quot;);</span></div><div class="token-line"><span class="token plain">            JSONObject pushJson = new JSONObject();</span></div><div class="token-line"><span class="token plain">            pushJson.put(&quot;type&quot;, 4);</span></div><div class="token-line"><span class="token plain">            pushJson.put(&quot;data&quot;, msgJson);</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            //最终调用网关层处理器将消息真正下推下去</span></div><div class="token-line"><span class="token plain">            websocketRouterHandler.pushMsg(otherUid, pushJson);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Override</span></div><div class="token-line"><span class="token plain">    public MessageVO sendNewMsg(long senderUid, long recipientUid, String content, int msgType) {</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //先对发送消息进行存储、加未读等操作</span></div><div class="token-line"><span class="token plain">        //...</span></div><div class="token-line"><span class="token plain">        // 然后将待推送消息发布到Redis</span></div><div class="token-line"><span class="token plain">        redisTemplate.convertAndSend(Constants.WEBSOCKET_MSG_TOPIC, JSONObject.toJSONString(messageVO));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，我们可以基于Redis的发布/订阅，实现一个消息推送的发布订阅器。</p><p>在业务层进行发送消息逻辑处理的最后，会将这条消息发布到Redis的一个Topic中，这个Topic被NewMessageListener一直监听着，如果有消息发布，那么监听器会马上感知到，然后再将消息提交给WebSocketRouterHandler，来进行最终消息的下推。</p><h3 id="消息推送的ack"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#消息推送的ack"><span class="icon icon-link"></span></a>消息推送的ACK</h3><p>我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/129751">“04 | ACK机制：如何保证消息的可靠投递？”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中有讲到，当系统有消息下推后，我们会依赖客户端响应的ACK包，来保证消息推送的可靠性。如果消息下推后一段时间，服务端没有收到客户端的ACK包，那么服务端会认为这条消息没有正常投递下去，就会触发重新下推。</p><p>关于ACK机制相应的服务端代码，你可以参考下面的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void pushMsg(long recipientUid, JSONObject message) {</span></div><div class="token-line"><span class="token plain">        channel.writeAndFlush(new TextWebSocketFrame(message.toJSONString()));</span></div><div class="token-line"><span class="token plain">        //消息推送下去后，将这条消息加入到待ACK列表中</span></div><div class="token-line"><span class="token plain">        addMsgToAckBuffer(channel, message);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    public void addMsgToAckBuffer(Channel channel, JSONObject msgJson) {</span></div><div class="token-line"><span class="token plain">        nonAcked.put(msgJson.getLong(&quot;tid&quot;), msgJson);</span></div><div class="token-line"><span class="token plain">        //定时器针对下推的这条消息在5s后进行&quot;是否ACK&quot;的检查</span></div><div class="token-line"><span class="token plain">        executorService.schedule(() -&gt; {</span></div><div class="token-line"><span class="token plain">            if (channel.isActive()) {</span></div><div class="token-line"><span class="token plain">                //检查是否被ACK，如果没有收到ACK回包，会触发重推</span></div><div class="token-line"><span class="token plain">                checkAndResend(channel, msgJson);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }, 5000, TimeUnit.MILLISECONDS);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    long tid = data.getLong(&quot;tid&quot;);</span></div><div class="token-line"><span class="token plain">    nonAcked.remove(tid);</span></div><div class="token-line"><span class="token plain">    private void checkAndResend(Channel channel, JSONObject msgJson) {</span></div><div class="token-line"><span class="token plain">        long tid = msgJson.getLong(&quot;tid&quot;);</span></div><div class="token-line"><span class="token plain">        //重推2次</span></div><div class="token-line"><span class="token plain">        int tryTimes = 2;                    </span></div><div class="token-line"><span class="token plain">        while (tryTimes &gt; 0) {</span></div><div class="token-line"><span class="token plain">            if (nonAcked.containsKey(tid) &amp;&amp; tryTimes &gt; 0) {</span></div><div class="token-line"><span class="token plain">                channel.writeAndFlush(new TextWebSocketFrame(msgJson.toJSONString()));</span></div><div class="token-line"><span class="token plain">                try {</span></div><div class="token-line"><span class="token plain">                    Thread.sleep(2000);</span></div><div class="token-line"><span class="token plain">                } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                    e.printStackTrace();</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            tryTimes--;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>用户在上线完成后，服务端会在这个连接维度的存储里，初始化一个起始值为0的序号（tid），每当有消息推送给客户端时，服务端会针对这个序号进行加1操作，下推消息时就会携带这个序号连同消息一起推下去。</p><p>消息推送后，服务端会将当前消息加入到一个“待ACK Buffer”中，这个ACK Buffer的实现，我们可以简单地用一个ConcurrentHashMap来实现，Key就是这条消息携带的序号，Value是消息本身。</p><p>当消息加入到这个“待ACK Buffer”时，服务端会同时创建一个定时器，在一定的时间后，会触发“检查当前消息是否被ACK”的逻辑；如果客户端有回ACK，那么服务端就会从这个“待ACK Buffer”中移除这条消息，否则如果这条消息没有被ACK，那么就会触发消息的重新下推。</p><h3 id="应用层心跳"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#应用层心跳"><span class="icon icon-link"></span></a>应用层心跳</h3><p>在了解了如何通过WebSocket长连接，来完成最核心的消息收发功能之后，我们再来看下，针对这个长连接，我们如何实现新增加的应用层心跳功能。</p><p>应用层心跳的作用，我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134231">第8课“智能心跳机制：解决网络的不确定性”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中也有讲到过，主要是为了解决由于网络的不确定性，而导致的连接不可用的问题。</p><p>客户端发送心跳包的主要代码设计如下，不过我这里的示例代码只是一个简单的实现，你可以自行参考，然后自己去尝试动手实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//每2分钟发送一次心跳包，接收到消息或者服务端的响应又会重置来重新计时。</span></div><div class="token-line"><span class="token plain">    var heartBeat = {</span></div><div class="token-line"><span class="token plain">        timeout: 120000,</span></div><div class="token-line"><span class="token plain">        timeoutObj: null,</span></div><div class="token-line"><span class="token plain">        serverTimeoutObj: null,</span></div><div class="token-line"><span class="token plain">        reset: function () {</span></div><div class="token-line"><span class="token plain">            clearTimeout(this.timeoutObj);</span></div><div class="token-line"><span class="token plain">            clearTimeout(this.serverTimeoutObj);</span></div><div class="token-line"><span class="token plain">            this.start();</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        start: function () {</span></div><div class="token-line"><span class="token plain">            var self = this;</span></div><div class="token-line"><span class="token plain">            this.timeoutObj = setTimeout(function () {</span></div><div class="token-line"><span class="token plain">                var sender_id = $(&quot;#sender_id&quot;).val();</span></div><div class="token-line"><span class="token plain">                var sendMsgJson = &#x27;{ &quot;type&quot;: 0, &quot;data&quot;: {&quot;uid&quot;:&#x27; + sender_id + &#x27;,&quot;timeout&quot;: 120000}}&#x27;;</span></div><div class="token-line"><span class="token plain">                websocket.send(sendMsgJson);</span></div><div class="token-line"><span class="token plain">                self.serverTimeoutObj = setTimeout(function () {</span></div><div class="token-line"><span class="token plain">                    websocket.close();</span></div><div class="token-line"><span class="token plain">                    $(&quot;#ws_status&quot;).text(&quot;失去连接！&quot;);</span></div><div class="token-line"><span class="token plain">                }, self.timeout)</span></div><div class="token-line"><span class="token plain">            }, this.timeout)</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>客户端通过一个定时器，每2分钟通过长连接给服务端发送一次心跳包，如果在2分钟内接收到服务端的消息或者响应，那么客户端的下次2分钟定时器的计时，会进行清零重置，重新计算；如果发送的心跳包在2分钟后没有收到服务端的响应，客户端会断开当前连接，然后尝试重连。</p><p>我在下面的代码示例中，提供的“服务端接收到心跳包的处理逻辑”的实现过程，其实非常简单，只是封装了一个普通回包消息进行响应，代码设计如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {</span></div><div class="token-line"><span class="token plain">        long uid = data.getLong(&quot;uid&quot;);</span></div><div class="token-line"><span class="token plain">        long timeout = data.getLong(&quot;timeout&quot;);</span></div><div class="token-line"><span class="token plain">        logger.info(&quot;[heartbeat]: uid = {} , current timeout is {} ms, channel = {}&quot;, uid, timeout, ctx.channel());</span></div><div class="token-line"><span class="token plain">        ctx.writeAndFlush(new TextWebSocketFrame(&quot;{\&quot;type\&quot;:0,\&quot;timeout\&quot;:&quot; + timeout + &quot;}&quot;));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们实际在线上实现的时候，可以采用前面介绍的“智能心跳”机制，通过服务端对心跳包的响应，来计算新的心跳间隔，然后返回给客户端来进行调整。</p><p>好，到这里，期末实战的主要核心功能基本上也讲解得差不多了，细节方面你可以再翻一翻我在<a target="_blank" rel="noopener noreferrer" href="https://github.com/coldwalker/Sample">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上提供的示例代码。</p><p>对于即时消息场景的代码实现来说，如果要真正达到线上使用的程度，相应的代码量是非常庞大的；而且对于同一个功能的实现，根据不同的使用场景和业务特征，很多业务在设计上也会有较大的差异性。</p><p>所以，实战课程的设计和示例代码只能做到挂一漏万，我尽量通过最简化的代码，来让你真正了解某一个功能在实现上最核心的思想。并且，通过期中和期末两个阶段的功能升级与差异对比，使你能感受到这些差异对于使用方体验和服务端压力的改善，从而可以更深刻地理解和掌握前面课程中相应的理论点。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect/即时消息技术剖析与实战/04.进阶篇/09#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天的期末实战，我们主要是针对期中实战中IM系统设计的功能，来进行优化改造。</p><p>比如，<strong>使用基于WebSocket的长连接</strong>，代替基于HTTP的短轮询，来提升消息的实时性，并增加了<strong>应用层心跳、ACK机制</strong>等新功能。</p><p>通过这次核心代码的讲解，是想让你能理论结合实际地去理解前面课程讲到的，IM系统设计中最重要的部分功能，也希望你能自己尝试去动手写一写。当然，你也可以基于已有代码，去增加一些之前课程中有讲到，但是示例代码中没有实现的功能，比如离线消息、群聊等。</p><p>最后再给你留一个思考题：<strong>ACK机制的实现中，如果尝试多次下推之后仍然没有成功，服务端后续应该进行哪些处理呢？</strong></p><p>以上就是今天课程的内容，欢迎你给我留言，我们可以在留言区一起讨论，感谢你的收听，我们下期再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/即时消息技术剖析与实战/04.进阶篇/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:47:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect/umi.ded6fefd.js"></script>
  </body>
</html>
